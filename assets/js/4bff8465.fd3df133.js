"use strict";(self.webpackChunkrendering=self.webpackChunkrendering||[]).push([[3526],{6107:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>a,default:()=>c,frontMatter:()=>t,metadata:()=>l,toc:()=>d});var n=r(4848),i=r(8453);const t={},a=void 0,l={id:"M1 GP/Partie 3 - Du vrai rendu 3D",title:"Partie 3 - Du vrai rendu 3D",description:"Charger un mesh depuis un fichier",source:"@site/docs/M1 GP/Partie 3 - Du vrai rendu 3D.md",sourceDirName:"M1 GP",slug:"/M1 GP/Partie 3 - Du vrai rendu 3D",permalink:"/Rendering/M1 GP/Partie 3 - Du vrai rendu 3D",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"M1GP",previous:{title:"Partie 2 - Bases du rendu",permalink:"/Rendering/M1 GP/Partie 2 - Bases du rendu"}},o={},d=[{value:"Charger un mesh depuis un fichier",id:"charger-un-mesh-depuis-un-fichier",level:2},{value:"Premier mod\xe8le d&#39;\xe9clairage et Normales",id:"premier-mod\xe8le-d\xe9clairage-et-normales",level:2},{value:"Normales",id:"normales",level:3},{value:"Lumi\xe8re directionnelle",id:"lumi\xe8re-directionnelle",level:3},{value:"Lumi\xe8re ambiante",id:"lumi\xe8re-ambiante",level:3},{value:"Lumi\xe8re ponctuelle",id:"lumi\xe8re-ponctuelle",level:3},{value:"Normal Matrix et Model Matrix",id:"normal-matrix-et-model-matrix",level:3},{value:"Lumi\xe8res color\xe9es",id:"lumi\xe8res-color\xe9es",level:3},{value:"\xc0 vous de jouer !",id:"\xe0-vous-de-jouer-",level:2},{value:"Normal maps",id:"normal-maps",level:3},{value:"Ombres",id:"ombres",level:3},{value:"Effet see-through",id:"effet-see-through",level:3},{value:"Mat\xe9riaux et mod\xe8les d&#39;\xe9clairages plus avanc\xe9s",id:"mat\xe9riaux-et-mod\xe8les-d\xe9clairages-plus-avanc\xe9s",level:3}];function u(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mrow:"mrow",msup:"msup",ol:"ol",p:"p",pre:"pre",section:"section",semantics:"semantics",span:"span",strong:"strong",sup:"sup",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h2,{id:"charger-un-mesh-depuis-un-fichier",children:"Charger un mesh depuis un fichier"}),"\n",(0,n.jsxs)(s.p,{children:["Pour commencer, nous allons enfin utiliser de vrais mod\xe8les 3D. Pour cela, nous allons utiliser la librairie ",(0,n.jsx)(s.a,{href:"https://github.com/tinyobjloader/tinyobjloader",children:(0,n.jsx)(s.em,{children:"tinyobjloader"})})," qui lit le format de fichier ",(0,n.jsx)(s.em,{children:".obj"})," (un format simple de mod\xe8le 3D, qui est essentiellement une longue liste de sommets avec positions, UVs, normales, etc.). La librairie est d\xe9j\xe0 inclue par ",(0,n.jsx)(s.em,{children:"opengl-framework"}),", vous n'avez rien \xe0 faire de ce c\xf4t\xe9 l\xe0."]}),"\n",(0,n.jsxs)(s.p,{children:["Il va nous falloir cr\xe9er un tableau de floats qu'on va remplir avec les positions, UVs et normales du mesh, et nous allons ensuite utiliser ce tableau comme ",(0,n.jsx)(s.code,{children:"data"})," pour cr\xe9er un ",(0,n.jsx)(s.code,{children:"gl::Mesh"})," :"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cpp",children:'auto load_mesh(std::filesystem::path const& path) -> gl::Mesh\n{\n    // On lit le fichier avec tinyobj\n    auto reader = tinyobj::ObjReader{};\n    reader.ParseFromFile(gl::make_absolute_path(path).string(), {});\n\n    if (!reader.Error().empty())\n        throw std::runtime_error("Failed to read 3D model:\\n" + reader.Error());\n    if (!reader.Warning().empty())\n        std::cout << "Warning while reading 3D model:\\n" + reader.Warning();\n\n    // On met tous les attributs dans un tableau\n    auto vertices = std::vector<float>{};\n    for (auto const& shape : reader.GetShapes())\n    {\n        for (auto const& idx : shape.mesh.indices)\n        {\n            // Position\n            vertices.push_back(reader.GetAttrib().vertices[3 * idx.vertex_index + 0]);\n            vertices.push_back(reader.GetAttrib().vertices[3 * idx.vertex_index + 1]);\n            vertices.push_back(reader.GetAttrib().vertices[3 * idx.vertex_index + 2]);\n\n            // UV\n            vertices.push_back(reader.GetAttrib().texcoords[2 * idx.texcoord_index + 0]);\n            vertices.push_back(reader.GetAttrib().texcoords[2 * idx.texcoord_index + 1]);\n\n            // Normale\n            vertices.push_back(reader.GetAttrib().normals[3 * idx.normal_index + 0]);\n            vertices.push_back(reader.GetAttrib().normals[3 * idx.normal_index + 1]);\n            vertices.push_back(reader.GetAttrib().normals[3 * idx.normal_index + 2]);\n        };\n    }\n\n    // TODO cr\xe9er et return un gl::mesh, qui utilisera le tableau `vertices` en tant que `data` pour son vertex buffer.\n    // Attention, il faudra bien sp\xe9cifier le layout pour qu\'il corresponde \xe0 l\'ordre des attributs dans le tableau `vertices`.\n}\n'})}),"\n",(0,n.jsxs)(s.p,{children:["Compl\xe9tez la fonction ci-dessus pour construire un mesh \xe0 partir du tableau de vertices obtenu gr\xe2ce \xe0 tinyobj. Il vous suffit ensuite de remplacer votre mesh de cube par un mesh load\xe9 avec cette fonction, et le tour est jou\xe9 ! Pour vos tests, vous pouvez utiliser ",(0,n.jsx)(s.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:r(2674).A+"",children:"ce mod\xe8le 3D"})," et le mettre dans votre dossier ",(0,n.jsx)(s.em,{children:"res"}),"."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(4350).A+"",width:"1920",height:"1030"})}),"\n",(0,n.jsx)(s.admonition,{type:"tip",children:(0,n.jsx)(s.p,{children:"Si votre mod\xe8le est pench\xe9 sur le c\xf4t\xe9 au d\xe9but, c'est \"normal\". Il n'y a pas de convention universelle pour l'axe qui pointe vers le haut : certaines utilisent Y, et d'autres Z. Il faudra donc l\xe9g\xe8rement modifier les vertexs du mesh au moment du loading afin de faire pointer le bon axe vers le haut."})}),"\n",(0,n.jsx)(s.admonition,{type:"tip",children:(0,n.jsxs)(s.p,{children:["N'essayez pas de faire un index buffer, les sommets tels qu'ils sont donn\xe9s par ",(0,n.jsx)(s.em,{children:"tinyobjloader"})," ont un index buffer diff\xe9rent pour chaque attribut, ce qui n'est pas support\xe9 par OpenGL. Il faudrait plut\xf4t inspecter tous les sommets pour d\xe9tecter ceux qui ont les m\xeames positions ",(0,n.jsx)(s.strong,{children:"et"})," UVs ",(0,n.jsx)(s.strong,{children:"et"})," normales et recr\xe9er notre propre index buffer \xe0 partir de \xe7a."]})}),"\n",(0,n.jsx)(s.admonition,{title:"Note",type:"info",children:(0,n.jsxs)(s.p,{children:["Il y a aussi un fichier ",(0,n.jsx)(s.em,{children:".mtl"})," dans le mod\xe8le que je vous ai fourni. Il d\xe9crit le mat\xe9riau de l'objet, nous en parlerons ",(0,n.jsx)(s.a,{href:"TODO",children:"plus tard"}),"."]})}),"\n",(0,n.jsx)(s.h2,{id:"premier-mod\xe8le-d\xe9clairage-et-normales",children:"Premier mod\xe8le d'\xe9clairage et Normales"}),"\n",(0,n.jsx)(s.h3,{id:"normales",children:"Normales"}),"\n",(0,n.jsxs)(s.p,{children:["Nous allons maintenant commencer \xe0 \xe9clairer plus ou moins nos objets en fonction des diff\xe9rentes lumi\xe8res pr\xe9sentes dans la sc\xe8ne. Tout va se passer dans le fragment shader, qui va \xeatre responsable de faire ces calculs pour chaque pixel, et d'att\xe9nuer plus ou moins la couleur de base du pixel (appel\xe9e ",(0,n.jsx)(s.strong,{children:"albedo"}),") en fonction de la quantit\xe9 de lumi\xe8re re\xe7ue."]}),"\n",(0,n.jsxs)(s.p,{children:["Pour faire ces calculs de lumi\xe8re, nous avons besoin de conna\xeetre l'orientation de notre surface (pour savoir \xe0 quel point elle est face \xe0 la lumi\xe8re) et c'est \xe0 \xe7a que servent les ",(0,n.jsx)(s.strong,{children:"normales"})," :"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(838).A+"",width:"300",height:"234"})}),"\n",(0,n.jsxs)(s.p,{children:["La normale est le vecteur perpendiculaire \xe0 la surface ; on pourrait le calculer \xe0 la vol\xe9e en connaissant les trois sommets du triangle, mais il est le plus souvent pr\xe9calcul\xe9 et stock\xe9 dans le vertex buffer. Par exemple dans le ",(0,n.jsx)(s.em,{children:".obj"})," que nous utilisons, les normales sont d\xe9j\xe0 stock\xe9es dans le fichier, en plus des positions et des UVs. Rajoutez les normales dans votre vertex buffer, et dans un premier temps pour v\xe9rifier qu'elles sont bonnes, affichez les en tant que couleur de l'objet :"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(1089).A+"",width:"1920",height:"1030"})}),"\n",(0,n.jsx)(s.p,{children:"On peut interpr\xe9ter les couleurs : RGB = XYZ : en bleu ce sont les normales qui pointent vers Z, i.e. vers le haut. En rouge et vert sont celles qui pointent vers X et Y."}),"\n",(0,n.jsx)(s.h3,{id:"lumi\xe8re-directionnelle",children:"Lumi\xe8re directionnelle"}),"\n",(0,n.jsx)(s.p,{children:"Maintenant il nous faut d\xe9crire notre lumi\xe8re. Nous allons commencer par le type le plus simple, les lumi\xe8res directionnelles. C'est une lumi\xe8re qui \xe9claire dans une seule direction ; c'est typiquement le cas du soleil (ou toute autre source tr\xe8s \xe9loign\xe9e), dont tous les rayons nous arrivent (quasiment) parall\xe8les :"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(7519).A+"",width:"250",height:"250"})}),"\n",(0,n.jsxs)(s.p,{children:["Pour la d\xe9crire il nous suffit de donner sa direction, qui sera un ",(0,n.jsx)(s.code,{children:"vec3"})," normalis\xe9 (i.e. de longueur 1). On peut soit la mettre en constante dans le fragment shader ",(0,n.jsx)(s.code,{children:"const vec3 light_direction = normalize(vec3(0.2, 0.3, -1.));"}),", soit la passer en uniform ",(0,n.jsx)(s.code,{children:"uniform vec3 light_direction;"})," (ce qui est l'option la plus courante, car on veut pouvoir changer la direction de notre lumi\xe8re sans avoir \xe0 recr\xe9er un nouveau shader \xe0 chaque fois).",(0,n.jsx)("br",{}),"\nUne fois que vous avez cette direction, pour mesurer \xe0 quel point notre triangle fait face \xe0 la lumi\xe8re (et donc \xe0 quel point il est \xe9clair\xe9) nous allons utiliser le ",(0,n.jsx)(s.em,{children:"produit scalaire"})," (",(0,n.jsx)(s.code,{children:"dot(v1, v2)"})," en glsl). Le produit scalaire entre deux vecteurs parfaitement align\xe9s vaut 1 (si les vecteurs sont normalis\xe9s), il vaut -1 si les vecteurs sont parfaitement oppos\xe9s, et il vaut 0 si les vecteurs sont orthogonaux. On peut ensuite multiplier la couleur de notre pixel par le r\xe9sultat de ce produit scalaire (avec un signe moins), ce qui va nous donner un premier mod\xe8le d'\xe9clairage simpliste : Quand la normale et la direction de la lumi\xe8re sont parfaitement oppos\xe9es c'est l'\xe9clairage maximal, et on va multiplier par un produit scalaire qui vaut 1, donc conserver toute la couleur du pixel. \xc0 l'inverse quand les vecteurs sont perpendiculaires aucune lumi\xe8re n'arrive sur notre surface, et \xe7a correspond bien au fait de multiplier par un produit scalaire qui vaut 0 dans ce cas."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(8376).A+"",width:"1920",height:"1030"})}),"\n",(0,n.jsx)(s.admonition,{type:"tip",children:(0,n.jsxs)(s.p,{children:["Pour nos produits scalaires on a besoin que les deux vecteurs soient normalis\xe9s, donc pensez bien \xe0 ",(0,n.jsx)(s.strong,{children:"toujours normaliser vos normales"})," !",(0,n.jsx)("br",{}),"\nEt attention, il y a des petits pi\xe8ges : par exemple si vos normales sont normalis\xe9es dans le vertex shader, et qu'ensuite vous les passez au fragment shader via une variable ",(0,n.jsx)(s.code,{children:"in"})," / ",(0,n.jsx)(s.code,{children:"out"}),", elles ne seront plus normalis\xe9es, car l'interpolation entre les sommets se produit, et la moyenne de vecteurs normalis\xe9s n'est pas n\xe9cessairement normalis\xe9e."]})}),"\n",(0,n.jsx)(s.h3,{id:"lumi\xe8re-ambiante",children:"Lumi\xe8re ambiante"}),"\n",(0,n.jsxs)(s.p,{children:["Un premier d\xe9faut qu'on peut tout de suite voir c'est que certaines parties du bateau sont compl\xe8tement noires, car elles sont \xe0 l'oppos\xe9 de la lumi\xe8re. Ce n'est pas tr\xe8s r\xe9aliste, car dans la vraie vie m\xeame si on n'est pas directement expos\xe9 \xe0 la lumi\xe8re celle-ci rebondit sur les objets environnants et vient \xe9clairer un peu partout. C'est ce qui s'appelle de ",(0,n.jsx)(s.strong,{children:"l'illumination globale"}),". Il y a des techniques pour simuler \xe7a dans les moteurs de jeu, mais \xe7a devient assez complexe. Pour faire simple on peut juste rajouter un terme de ",(0,n.jsx)(s.strong,{children:"lumi\xe8re ambiante"})," qui va faire une approximation de cette illumination globale. Il suffit d'additionner un petit quelque chose (",(0,n.jsx)(s.code,{children:"0.3"})," par exemple) \xe0 notre produit scalaire, pour l'emp\xeacher de tomber jusqu'\xe0 0 (et aussi, si le produit scalaire devient n\xe9gatif, il faut le limiter \xe0 0, afin que notre ",(0,n.jsx)(s.code,{children:"+0.3"})," ait de l'effet dans toutes les zones noires, et pas seulement dans celles o\xf9 le produit scalaire est ",(0,n.jsx)(s.code,{children:"> -0.3"}),")."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(2867).A+"",width:"1920",height:"1030"})}),"\n",(0,n.jsx)(s.h3,{id:"lumi\xe8re-ponctuelle",children:"Lumi\xe8re ponctuelle"}),"\n",(0,n.jsxs)(s.p,{children:["Un autre type de lumi\xe8re assez simple est la lumi\xe8re ponctuelle. Elle est d\xe9crite par une position (",(0,n.jsx)(s.code,{children:"vec3"}),") et illumine de mani\xe8re \xe9gale dans toutes les directions autour d'elle. C'est typiquement le cas des ampoules et autres petites sources de lumi\xe8re."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(7909).A+"",width:"239",height:"279"})}),"\n",(0,n.jsxs)(s.p,{children:["Le calcul d'\xe9clairage est le m\xeame que pour une lumi\xe8re directionnelle. Mais il nous faut d'abord calculer la direction de la lumi\xe8re, qui cette fois-ci d\xe9pend de la position du pixel concern\xe9. Il faut donc r\xe9cup\xe9rer la position dans le fragment shader, puis calculer le vecteur entre la position du pixel et la position de la lumi\xe8re. De plus, l'intensit\xe9 d'une lumi\xe8re ponctuelle d\xe9cro\xeet \xe0 mesure qu'on s'en \xe9loigne, donc il faut diviser le tout par la distance au carr\xe9",(0,n.jsx)(s.sup,{children:(0,n.jsx)(s.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),"."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(2106).A+"",width:"1920",height:"1030"})}),"\n",(0,n.jsx)(s.admonition,{type:"tip",children:(0,n.jsx)(s.p,{children:"Pour contr\xf4ler l'influence des diff\xe9rentes lumi\xe8res, vous pouvez leur rajouter une intensit\xe9 (a.k.a. un nombre que vous allez multiplier au r\xe9sultat du produit scalaire) afin d'augmenter ou diminuer l'effet d'une lumi\xe8re."})}),"\n",(0,n.jsx)(s.h3,{id:"normal-matrix-et-model-matrix",children:"Normal Matrix et Model Matrix"}),"\n",(0,n.jsx)(s.p,{children:"Si on se met \xe0 appliquer une matrice mod\xe8le \xe0 notre objet, par exemple pour le faire tourner, on se rend compte d'un petit probl\xe8me :"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(8300).A+"",width:"1271",height:"714"})}),"\n",(0,n.jsx)(s.p,{children:"L'\xe9clairage ne prend pas en compte la transformation de notre objet ! C'est comme si il ne tournait pas aux yeux de la lumi\xe8re ! C'est parce que les positions et normales qu'on r\xe9cup\xe8re depuis le vertex buffer sont exprim\xe9es en Object Space, alors que la position / direction de notre lumi\xe8re est en World Space. Pour pouvoir faire nos calculs il faut que tout soit exprim\xe9 dans le m\xeame rep\xe8re ! Pour convertir les positions et normales de nos pixels depuis l'Object Space vers le World Space, il faut leur appliquer la Model Matrix. Et je vous donne ces deux fonctions pour appliquer correctement une matrice \xe0 une position et \xe0 une direction en prenant bien en compte les coordonn\xe9es homog\xe8nes :"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-glsl",children:"vec3 apply_matrix_to_position(mat4 matrix, vec3 point)\n{\n    vec4 tmp = matrix * vec4(point, 1.);\n    return tmp.xyz / tmp.w;\n}\n\nvec3 apply_matrix_to_direction(mat4 matrix, vec3 direction)\n{\n    vec4 tmp = matrix * vec4(direction, 0.);\n    return normalize(tmp.xyz);\n}\n"})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(9159).A+"",width:"1270",height:"712"})}),"\n",(0,n.jsxs)(s.admonition,{type:"tip",children:[(0,n.jsxs)(s.p,{children:["Pour \xe9viter toute confusion \xe0 l'avenir, je vous conseille de toujours ajouter un petit suffixe \xe0 vos variables de position et direction, pour bien indiquer dans quel espace elles sont exprim\xe9es : par exemple ",(0,n.jsx)(s.code,{children:"_os"})," pour object space, ",(0,n.jsx)(s.code,{children:"_ws"})," pour world space, ",(0,n.jsx)(s.code,{children:"_vs"})," pour view space, etc."]}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-glsl",children:"layout(location = 0) in vec3 in_position_os;\nuniform mat4 model_matrix;\n\nout vec3 position_ws;\n// ...\n\nvoid main()\n{\n    // ...\n    position_ws = apply_matrix_to_position(model_matrix, in_position_os);\n    // ...\n}\n"})})]}),"\n",(0,n.jsxs)(s.p,{children:["De plus, ce n'est pas tout \xe0 fait la Model Matrix qu'il faut appliquer aux normales, mais la ",(0,n.jsx)(s.strong,{children:"Normal Matrix"}),", qui est l'inverse de la transpos\xe9e de la Model Matrix (",(0,n.jsx)(s.code,{children:"glm::inverse(glm::transpose(model_matrix))"}),"). \xc7a revient au m\xeame dans la plupart des cas, mais si jamais il y a une scale non-uniforme dans votre model matrix, alors \xe7a d\xe9formerait les normales et il faut passer par la Normal Matrix pour corriger \xe7a."]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.img,{src:r(8693).A+"",width:"550",height:"325"}),(0,n.jsx)("br",{}),"\n",(0,n.jsx)(s.em,{children:"Normales incorrectement transform\xe9es par la Model Matrix"})]}),"\n",(0,n.jsxs)(s.p,{children:["Si vous voulez savoir d'o\xf9 vient la normal matrix et pourquoi c'est l'inverse de la transpos\xe9e, je vous recommande ",(0,n.jsx)(s.a,{href:"http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/",children:"ce petit article"}),"."]}),"\n",(0,n.jsx)(s.h3,{id:"lumi\xe8res-color\xe9es",children:"Lumi\xe8res color\xe9es"}),"\n",(0,n.jsxs)(s.p,{children:["On peut aussi associer une couleur \xe0 chaque lumi\xe8re, simplement en multipliant sa contribution par la couleur d\xe9sir\xe9e (",(0,n.jsx)(s.code,{children:"vec3"}),") :"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(7572).A+"",width:"1920",height:"1030"})}),"\n",(0,n.jsx)(s.h2,{id:"\xe0-vous-de-jouer-",children:"\xc0 vous de jouer !"}),"\n",(0,n.jsx)(s.p,{children:'Voici diff\xe9rents effets "avanc\xe9s" que vous pouvez impl\xe9menter maintenant que vous connaissez les bases du rendu 3D !'}),"\n",(0,n.jsx)(s.h3,{id:"normal-maps",children:"Normal maps"}),"\n",(0,n.jsxs)(s.p,{children:["Les normal maps permettent d'ajouter du d\xe9tail \xe0 un mesh en modifiant la normale pour chaque pixel du triangle. ",(0,n.jsx)(s.a,{href:"https://learnopengl.com/Advanced-Lighting/Normal-Mapping",children:"Voici par exemple un tuto que vous pouvez suivre pour impl\xe9menter des normal maps."})," ",(0,n.jsx)(s.a,{href:"https://youtu.be/JNj1A1bl7gg?list=PLPaoO-vpZnumdcb4tZc4x5Q-v7CkrQ6M-",children:"Et le m\xeame en version vid\xe9o."})]}),"\n",(0,n.jsx)(s.h3,{id:"ombres",children:"Ombres"}),"\n",(0,n.jsxs)(s.p,{children:["Les shadow maps permettent de produire des ombres ",(0,n.jsx)(s.strong,{children:"pour les lumi\xe8res directionnelles"}),". C'est le point de d\xe9part de toute une famille de technique plus raffin\xe9es, comme les ",(0,n.jsx)(s.em,{children:"omnidirectional shadow maps"})," qui g\xe8rent les lumi\xe8res ponctuelles, et les ",(0,n.jsx)(s.em,{children:"cascaded shadow maps"})," qui am\xe9liorent la qualit\xe9 des ombres. ",(0,n.jsx)(s.a,{href:"https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping",children:"Voici par exemple un tuto que vous pouvez suivre pour impl\xe9menter une shadow map basique."})," (Et vous verrez, c'est d\xe9j\xe0 un peu costaud !) ",(0,n.jsx)(s.a,{href:"https://youtu.be/9g-4aJhCnyY?list=PLPaoO-vpZnumdcb4tZc4x5Q-v7CkrQ6M-",children:"Et le m\xeame tuto en version vid\xe9o."})]}),"\n",(0,n.jsx)(s.h3,{id:"effet-see-through",children:"Effet see-through"}),"\n",(0,n.jsx)(s.p,{children:"Pour faire cette effet o\xf9 on voit une silhouette des objets \xe0 travers les murs, il vous suffit, une fois toute la sc\xe8ne rendue normalement, de redessiner une deuxi\xe8me fois l'objet sur lequel vous voulez appliquer l'effet, avec ce setup particulier :"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Appliquer un shader sp\xe9cial qui va donner le visuel de la silhouette, par exemple retourner une couleur unie pour faire simple"}),"\n",(0,n.jsxs)(s.li,{children:["Changer le depth test, pour que l'objet ne s'affiche que si il est derri\xe8re d'autres objets. Je vous r\xe9f\xe8re \xe0 la documentation de ",(0,n.jsx)(s.a,{href:"https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml",children:(0,n.jsx)(s.code,{children:"glDepthFunc"})})," pour voir comment faire \xe7a."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{src:r(549).A+"",width:"1437",height:"883"})}),"\n",(0,n.jsx)(s.h3,{id:"mat\xe9riaux-et-mod\xe8les-d\xe9clairages-plus-avanc\xe9s",children:"Mat\xe9riaux et mod\xe8les d'\xe9clairages plus avanc\xe9s"}),"\n",(0,n.jsx)(s.p,{children:"Je vous r\xe9f\xe8re \xe0 ces tutos :"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.a,{href:"https://learnopengl.com/Lighting/Basic-Lighting",children:"Basic Lighting"}),", il y a un peu de redite de ce qu'on a vu, mais aussi des nouveaut\xe9s"]}),"\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.a,{href:"https://learnopengl.com/Lighting/Materials",children:"Materials"})}),"\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.a,{href:"https://learnopengl.com/Advanced-Lighting/Advanced-Lighting",children:"Blinn-Phong"})}),"\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.a,{href:"https://learnopengl.com/PBR/Theory",children:"PBR part 1"})}),"\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.a,{href:"https://learnopengl.com/PBR/Lighting",children:"PBR part 2"})}),"\n"]}),"\n",(0,n.jsxs)(s.section,{"data-footnotes":!0,className:"footnotes",children:[(0,n.jsx)(s.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{id:"user-content-fn-1",children:["\n",(0,n.jsxs)(s.p,{children:["C'est d\xfb au principe physique de conservation d'\xe9nergie : \xe0 un instant ",(0,n.jsx)(s.em,{children:"t"})," la source \xe9met une certaine quantit\xe9 d'\xe9nergie, et cette \xe9nergie s'\xe9loigne de la source, formant une sph\xe8re de plus en plus grande. Comme la m\xeame quantit\xe9 d'\xe9nergie doit \xeatre pr\xe9sente sur une sph\xe8re de plus en plus grande, l'\xe9nergie en un point donn\xe9 doit d\xe9cro\xeetre proportionnellement \xe0 la surface de la sph\xe8re, soit ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msup,{children:[(0,n.jsx)(s.mi,{children:"R"}),(0,n.jsx)(s.mn,{children:"2"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"R^2"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8141em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.00773em"},children:"R"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsx)(s.span,{className:"vlist-t",children:(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.8141em"},children:(0,n.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"2"})})]})})})})})]})]})})]}),". ",(0,n.jsx)(s.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},2674:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/files/fourareen-fa4bc93def8c839a6e356b89533490ee.zip"},7519:(e,s,r)=>{r.d(s,{A:()=>n});const n="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAD6CAMAAAC/MqoPAAADAFBMVEUsPlAtP1AtP1EuP1EuQFIvQFIwQlMxQ1QxQ1UyQ1UyRFUzRFYzRVY0Rlc1Rlc2R1g4SVo7TFw9TV49Tl4/UGBAUGBAUGFAUWFBUmJCUmNFVWVHV2dKWWhKWWlKWmlMXGtPXm1PX25RYG9TYXBUYnFVY3JWZXNYZnRYZnVZZ3VbaXddanhea3lgbntjcH1lcn9odIFodYJqd4NteYZve4hyfop0gIx2go53go55hJB7h5J+iZR/ipWAi5aDjZiFkJqHkZuIkpyKlJ6Nl6CPmaKSm6STnKWUnaaXn6iXoKmZoqucpK2epq+fp6+hqbGjq7OmrbWor7eosLersrmttLuvtr2wtr2yub+1u8G3vcO5v8W8wse+xMm+xMrBxszDyc7Eyc7Gy9DIzdLLz9TN0tbQ1NjS1trV2NzX2t7X297a3eDc3+Le4eTf4eTh5Obi5Ofk5ujl5+jm6Orp6+zr7e/s7e/u7/Hw8fPxxA/xxRLxxRXxxhfyxxryyCDyySPyyibyyijzyyvzzC7zzDHzzTTzzjfzzjnz9PX0zzz00D/00EL00UX00kf000r100311FD11VP11Vb11lj111v19vf211722GH22WT22mf22mn222z33G/33HL33XX33nf33nr333344ID44IP44Yb44oj444v44474+Pn55JH55ZT55Zf55pn555z555/66KL66aX66af66qr666367LD6+vv77LP77bb77rj77rv777778MH88MT88cf88sn888z888/89NL99dX99df99tr999399+D9+OP9/f3++eb++ej++uv+++7+/PH+/PT//ff//vn//vz///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACxasTxAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4gwLCCgw8D61lwAAAAd0RVh0QXV0aG9yAKmuzEgAAAAMdEVYdERlc2NyaXB0aW9uABMJISMAAAAK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"},8693:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/normal-matrix-6a3052eb71ed34fcd177743745caf4bb.png"},838:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/normals-af2aae03b46ad33cee0b221b8fa03a3b.png"},7909:(e,s,r)=>{r.d(s,{A:()=>n});const n="data:image/png;base64,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EH9feeU1Rdd27bxl3bqM69IgfS+QKpXauYkJ+IoCTCP4XXdmdrpWqTxw6NOBSw1HOjpOJ9lfvCHYbGWY5dDrNs/bA5Zjcwzucl3/+ed/g5R8y+49SBf9/f2GkbDs2oULF86fPz9VKOAuP3Bx8/XXX/vMoQe++pW/CjzH0A3XqeH90OxTcYn1Ya5IT9u8UB1wJZspKkBiXdcrlUo6nZ4tlp955hk09vbu3XvDTTemU32ox++eOP7SSy+999574+Pj0Hrz5s3f+MbX/+Lzn6UFhIFCv/RKX9Vejs2AhV4RvWvzFb1Z1GZYiEcCGIkH+H44OTn9xhtvVO3a4OAgLB8eHn7t1dd/9/vfVSrVBx984JFHHtm5/WY/gMOeqamO65i6gT9vljQAC71qetTm5RizwOaLXRB2rWbSj00ptm2bpolSremq70s//OG//fa3vz169GjNdU6ePPXgg4cef/wfPnbvQfqb6K9RjgPfVVXqpUYJV5c8FshCr45etHmZrixqMwh8f/64NP0pfTmKmnflcvXll19GXF4/sPGuu+7Cs1CTUdVUVfF8OjmdSce1pWKxmM1mmyWNeVjoVdBzNi/fkmY2ozwbZhLLCehgdaio2IaS49KvRiB+KLJiOzayNSbwYDpcomp4HOqxLNf75lzH0Y36rwkuAQu9UnrL5q7zg4VeEVf4vBOJbjSjYSUbXgLTQK/U5s6oPP8srV0+V+hlIkhtxv6Oqd++lIb5XWdDwwov8TJj6rd7D/GTRsPe7dLCtkyhexzBbRZD5RgW+oqIbLNIKsew0EsjrM3iqRzDQi+BmDaLqnIMC90MWfqPc/XJruZr18XXW5/+zKmHno2n63TyBc6tRieedP65Ii554WLs05UjWm2+mip3mEtfWuML70mE7tMQvkT1ag1uhrg298ieZqEXIKjNPbWPWeg55CfenahPdjOP7RqoTy2D9r3k+dVo+VNcIy/wGkfo3Mz0GGwzIw6CJI1rhPYlDWY5cG1mxIFtZsSBbWbEgW1mxIFtZsSBbWbEgW1mxIFt7hCP7RqIL/XbTBtgm1fJitRkiTsD27wmlqMpq9wx2Oa1srSsDffyEe+2wja3gGZCs8odhm1eJQ1qXi40q9x5eAzdmmhWlRvgjdwZuDavieVoyip3DLZ5rSwtK6vcSdjmFtBMWVa5w7DNreFycVnlzsM2t4yF+rLKVwXu02DEgWszIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIw5sMyMObDMjDmwzIwqS9P9GvvYgHpYhvAAAAABJRU5ErkJggg=="},549:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/see-through-bf42b78a4b1170ec204d66eaed824a8a.png"},4350:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/step-23-60a996da3d244e1bc650651e8cc943d1.png"},1089:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/step-24-9720c7b82789d4f7430b2136c42a7e4d.png"},8376:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/step-25-9afefcdb491b772dac267b45108590b1.png"},2867:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/step-26-5acefb16bd2997bab49f0370c0244218.png"},2106:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/step-27-b0eb124335371ac036b144c7146c60aa.png"},9159:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/step-28-correct-754ce01e25666b9c5d69a534ec8bce93.gif"},8300:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/step-28-incorrect-532636420dc4ac87f28e152f97034bee.gif"},7572:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/step-29-812852ae42cde76d879fe14dd1d2f84e.png"},8453:(e,s,r)=>{r.d(s,{R:()=>a,x:()=>l});var n=r(6540);const i={},t=n.createContext(i);function a(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);