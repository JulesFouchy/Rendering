"use strict";(self.webpackChunkrendering=self.webpackChunkrendering||[]).push([[956],{4557:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>a,default:()=>A,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var r=n(4848),t=n(8453);const i={},a=void 0,l={id:"M1 GP/Partie 2 - Bases du rendu",title:"Partie 2 - Bases du rendu",description:"La structure de l'application",source:"@site/docs/M1 GP/Partie 2 - Bases du rendu.md",sourceDirName:"M1 GP",slug:"/M1 GP/Partie 2 - Bases du rendu",permalink:"/Rendering/M1 GP/Partie 2 - Bases du rendu",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"M1GP",previous:{title:"Partie 1 - Setup",permalink:"/Rendering/M1 GP/Partie 1 - Setup"},next:{title:"Partie 3 - Du vrai rendu 3D",permalink:"/Rendering/M1 GP/Partie 3 - Du vrai rendu 3D"}},o={},d=[{value:"La structure de l&#39;application",id:"la-structure-de-lapplication",level:2},{value:"Couleur de fond",id:"couleur-de-fond",level:2},{value:"OpenGL",id:"opengl",level:2},{value:"Mesh",id:"mesh",level:2},{value:"Vertex Buffer et Premier Triangle",id:"vertex-buffer-et-premier-triangle",level:3},{value:"RenderDoc",id:"renderdoc",level:3},{value:"Dessiner un rectangle",id:"dessiner-un-rectangle",level:3},{value:"Index buffer",id:"index-buffer",level:3},{value:"Shader",id:"shader",level:2},{value:"GLSL",id:"glsl",level:3},{value:"Vertex Shader",id:"vertex-shader",level:3},{value:"Fragment Shader",id:"fragment-shader",level:3},{value:"Envoyer des param\xe8tres au shader : les uniforms",id:"envoyer-des-param\xe8tres-au-shader--les-uniforms",level:3},{value:"Exercice : Faire bouger le carr\xe9",id:"exercice--faire-bouger-le-carr\xe9",level:3},{value:"Bonus : effet de fade",id:"bonus--effet-de-fade",level:3},{value:"Cam\xe9ra et Matrices",id:"cam\xe9ra-et-matrices",level:2},{value:"View Matrix",id:"view-matrix",level:3},{value:"Projection Matrix",id:"projection-matrix",level:3},{value:"Envoyer au shader",id:"envoyer-au-shader",level:3},{value:"Exercice : param\xe8tres de la projection",id:"exercice--param\xe8tres-de-la-projection",level:3},{value:"Exercice : model matrix",id:"exercice--model-matrix",level:3},{value:"Cube",id:"cube",level:2},{value:"Premier shader pour mieux voir la 3D",id:"premier-shader-pour-mieux-voir-la-3d",level:2},{value:"Depth Buffer",id:"depth-buffer",level:2},{value:"Texture",id:"texture",level:2},{value:"UV",id:"uv",level:3},{value:"Objet Texture",id:"objet-texture",level:3},{value:"Options de texture",id:"options-de-texture",level:3},{value:"Wrap",id:"wrap",level:4},{value:"Filter",id:"filter",level:4},{value:"Bonus : textures proc\xe9durales",id:"bonus--textures-proc\xe9durales",level:3},{value:"Cube textur\xe9",id:"cube-textur\xe9",level:3},{value:"Render Target",id:"render-target",level:2},{value:"Post-Process",id:"post-process",level:3},{value:"Bonus : Fade",id:"bonus--fade",level:3},{value:"Autres utilisations",id:"autres-utilisations",level:3}];function c(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",mstyle:"mstyle",mtable:"mtable",mtd:"mtd",mtr:"mtr",ol:"ol",p:"p",path:"path",pre:"pre",section:"section",semantics:"semantics",span:"span",strong:"strong",sup:"sup",svg:"svg",table:"table",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h2,{id:"la-structure-de-lapplication",children:"La structure de l'application"}),"\n",(0,r.jsxs)(s.p,{children:["Pour l'instant dans ",(0,r.jsx)(s.code,{children:"src/main.cpp"})," vous avez ceci :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'#include "opengl-framework/opengl-framework.hpp" // Inclue la librairie qui va nous servir \xe0 faire du rendu\n\nint main()\n{\n    // Initialisation\n    gl::init("TPs de Rendering"); // On cr\xe9e une fen\xeatre et on choisit son nom\n    gl::maximize_window(); // On peut la maximiser si on veut\n\n    while (gl::window_is_open())\n    {\n        // Rendu \xe0 chaque frame\n    }\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["La boucle ",(0,r.jsx)(s.code,{children:"while"})," est ce qu'on appelle la ",(0,r.jsx)(s.em,{children:"boucle de rendu"})," ; chaque it\xe9ration correspond \xe0 ",(0,r.jsx)(s.em,{children:"une frame"}),", et il faudra y mettre le code dessinant ce qu'on veut pour cette frame."]}),"\n",(0,r.jsxs)(s.p,{children:["En ex\xe9cutant ce code, vous devriez avoir une fen\xeatre noire qui s'ouvre :\n",(0,r.jsx)(s.img,{src:n(6635).A+"",width:"1920",height:"1030"})]}),"\n",(0,r.jsx)(s.h2,{id:"couleur-de-fond",children:"Couleur de fond"}),"\n",(0,r.jsx)(s.p,{children:"Pour commencer tr\xe8s simplement on peut choisir la couleur de fond, au d\xe9but de la boucle de rendu :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"glClearColor(0.f, 0.f, 1.f, 1.f); // Choisis la couleur \xe0 utiliser. Les param\xe8tres sont R, G, B, A avec des valeurs qui vont de 0 \xe0 1\nglClear(GL_COLOR_BUFFER_BIT); // Ex\xe9cute concr\xe8tement l'action d'appliquer sur tout l'\xe9cran la couleur choisie au-dessus\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(5506).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.admonition,{title:"Note",type:"tip",children:(0,r.jsxs)(s.p,{children:["En plus de choisir la couleur, l'op\xe9ration ",(0,r.jsx)(s.code,{children:"glClear(GL_COLOR_BUFFER_BIT)"})," est tr\xe8s importante car elle reset l'image entre deux frames. Sans elle, les objets dessin\xe9s ne disparaissent pas d'une frame \xe0 l'autre (ce qui peut permettre des effets artistiques int\xe9ressants, mais est emb\xeatant pour un rendu \"classique\"). Vous pourrez essayer \xe7a ",(0,r.jsx)(s.a,{href:"#exercice--faire-bouger-le-carr%C3%A9",children:"un peu plus tard"})," quand nous saurons dessiner des objets qui bougent."]})}),"\n",(0,r.jsx)(s.h2,{id:"opengl",children:"OpenGL"}),"\n",(0,r.jsxs)(s.p,{children:["Nous utilisons l'API ",(0,r.jsx)(s.strong,{children:"OpenGL"})," pour communiquer avec la carte graphique. Il en existe d'autres, mais elles sont soit plus difficiles \xe0 apprendre (Vulkan, WebGPU), soit sp\xe9cifiques \xe0 un OS (DirectX pour Windows, Metal pour Mac)."]}),"\n",(0,r.jsxs)(s.p,{children:["Si jamais vous cherchez de l'aide sur Internet ou ChatGPT, pensez \xe0 bien pr\xe9ciser OpenGL dans votre recherche. Et sinon, vous trouverez la documentation de toutes les fonctions OpenGL sur ",(0,r.jsx)(s.a,{href:"https://docs.gl/",children:"docs.gl"}),"."]}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"info",children:(0,r.jsxs)(s.p,{children:["Tout ce qui commence par ",(0,r.jsx)(s.code,{children:"gl::"})," (comme ",(0,r.jsx)(s.code,{children:"gl::init()"}),") ne fait pas partie de l'API OpenGL de base, mais d'un wrapper que je vous fournis pour vous simplifier la vie. Par contre ce qui commence par ",(0,r.jsx)(s.code,{children:"gl"})," (comme ",(0,r.jsx)(s.code,{children:"glClearColor"}),") fait partie de l'API OpenGL officielle."]})}),"\n",(0,r.jsx)(s.h2,{id:"mesh",children:"Mesh"}),"\n",(0,r.jsx)(s.h3,{id:"vertex-buffer-et-premier-triangle",children:"Vertex Buffer et Premier Triangle"}),"\n",(0,r.jsxs)(s.p,{children:["Nous allons maintenant dessiner notre premier objet ! Pour d\xe9crire notre objet \xe0 la carte graphique, nous utilisons un ",(0,r.jsx)(s.strong,{children:"mesh"}),", c'est-\xe0-dire une longue liste de triangles qui, mis bout-\xe0-bout, dessinent notre forme en 3D :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(9301).A+"",width:"619",height:"638"})}),"\n",(0,r.jsxs)(s.p,{children:["Pendant l'initialisation nous pouvons cr\xe9er un objet de type ",(0,r.jsx)(s.code,{children:"gl::Mesh"})," :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"auto const triangle_mesh = gl::Mesh{{\n    .vertex_buffers = {{\n        .layout = {gl::VertexAttribute::Position2D{0 /*Index de l'attribut dans le shader, on en reparle juste apr\xe8s*/}},\n        .data   = {\n            -1.f, -1.f, // Position2D du 1er sommet\n            +1.f, -1.f, // Position2D du 2\xe8me sommet\n             0.f, +1.f  // Position2D du 3\xe8me sommet\n        },\n    }},\n}};\n"})}),"\n",(0,r.jsx)(s.p,{children:"que nous allons ensuite dessiner \xe0 chaque frame dans la boucle de rendu :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"gl::bind_default_shader(); // On a besoin qu'un shader soit bind (i.e. \"actif\") avant de draw(). On en reparle dans la section d'apr\xe8s.\ntriangle_mesh.draw(); // C'est ce qu'on appelle un \"draw call\" : on envoie l'instruction \xe0 la carte graphique de dessiner notre mesh.\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(1593).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Il y a d\xe9j\xe0 plein de chose \xe0 dire ! Quand on cr\xe9e un mesh, on lui passe un ",(0,r.jsx)(s.strong,{children:"vertex buffer"})," :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:".vertex_buffers = {{\n    .layout = {gl::VertexAttribute::Position2D{0 /*Index de l'attribut dans le shader, on en reparle juste apr\xe8s*/}},\n    .data   = {\n        -1.f, -1.f, // Position2D du 1er sommet\n        +1.f, -1.f, // Position2D du 2\xe8me sommet\n         0.f, +1.f  // Position2D du 3\xe8me sommet\n    },\n}},\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Un ",(0,r.jsx)(s.em,{children:"vertex buffer"})," c'est le tableau qui contient toutes les donn\xe9es d\xe9crivant notre mesh : position des sommets des triangles, mais \xe9galement plein d'autres donn\xe9es optionnelles : couleur, normale, coordonn\xe9e de texture (UV), etc.",(0,r.jsx)("br",{}),"\nEn fait c'est nous qui d\xe9cidons quoi mettre dans ce buffer, puis que faire de ces donn\xe9es quand on code le vertex shader (que nous verrons plus tard). Pour faire du rendu classique on utilise g\xe9n\xe9ralement position + normales + UV. Mais on peut aussi imaginer d'autres usages plus cr\xe9atifs et rajouter toutes les donn\xe9es dont on pourrait avoir besoin pour un effet pr\xe9cis."]}),"\n",(0,r.jsxs)(s.admonition,{title:"Remarque",type:"info",children:[(0,r.jsxs)(s.p,{children:["Un usage original : on peut stocker la distance au tronc sur chaque vertex des branches et feuilles des arbres. Cette distance est ensuite utilis\xe9e pour calculer \xe0 quel point la branche peut ployer sous l'effet du vent. (La partie attach\xe9e au tronc ne doit pas bouger, et plus on s'en \xe9loigne plus on peut bouger librement).",(0,r.jsx)("br",{}),"\nStocker cette distance dans le vertex buffer \xe9vite de la recalculer \xe0 chaque frame : c'est beaucoup plus optimis\xe9."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.a,{href:"https://youtu.be/MKX45_riWQA?t=1085",children:"C'est utilis\xe9 dans God of War par exemple :"}),"\n",(0,r.jsx)(s.img,{src:n(7606).A+"",width:"1920",height:"1080"})]})]}),"\n",(0,r.jsxs)(s.p,{children:["D\xe9crire ce vertex buffer se passe en deux \xe9tapes : son ",(0,r.jsx)(s.strong,{children:"layout"})," et ses ",(0,r.jsx)(s.strong,{children:"data"}),".",(0,r.jsx)("br",{}),"\nLe ",(0,r.jsx)(s.code,{children:"layout"})," indique comment ",(0,r.jsx)(s.code,{children:"data"})," est structur\xe9 : dans notre exemple on a juste des positions 2D qui s'encha\xeenent, mais \xe7a pourrait aussi \xeatre des positions 3D, et on pourrait aussi avoir d'autres attributs dans le m\xeame tableau ",(0,r.jsx)(s.code,{children:"data"}),", par exemple des coordonn\xe9es de texture, comme on verra ",(0,r.jsx)(s.a,{href:"TODO",children:"plus tard"}),". Pour chaque ",(0,r.jsx)(s.em,{children:"attribut"})," du layout, il faut pr\xe9ciser son ",(0,r.jsx)(s.em,{children:"index"})," (",(0,r.jsx)(s.code,{children:"0"})," dans notre cas), une information qui nous servira plus tard pour r\xe9cup\xe9rer l'attribut du c\xf4t\xe9 du ",(0,r.jsx)(s.em,{children:"shader"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["Vous remarquerez aussi que ",(0,r.jsx)(s.code,{children:"vertex_buffers"})," est un tableau de vertex buffers ! Il est en effet possible d'avoir plusieurs vertex buffers, par exemple un qui stocke les positions, et un autre qui stocke les normales. \xc7a revient au m\xeame que de mettre tous les attributs dans le m\xeame vertex buffer, mais \xe7a peut avoir des performances soit meilleures soit pires, en fonction des situations. C'est une question un peu compliqu\xe9e dont nous ne soucierons pas, et nous utiliserons simplement ce qui est le plus pratique pour nous."]}),"\n",(0,r.jsxs)(s.p,{children:["Enfin, dans ",(0,r.jsx)(s.code,{children:"data"})," nous mettons nos positions 2D :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:".data = {\n    -1.f, -1.f, // Position2D du 1er sommet\n    +1.f, -1.f, // Position2D du 2\xe8me sommet\n     0.f, +1.f  // Position2D du 3\xe8me sommet\n},\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Le syst\xe8me de coordonn\xe9es marche ainsi : ",(0,r.jsx)(s.strong,{children:"x et y vont toujours de -1 \xe0 1"}),". Ainsi, ",(0,r.jsx)(s.code,{children:"x = -1"})," repr\xe9sente toujours le c\xf4t\xe9 gauche de la fen\xeatre, et ",(0,r.jsx)(s.code,{children:"y = 1"})," repr\xe9sente toujours le haut de la fen\xeatre. Vous remarquerez donc que quand vous redimensionnez la fen\xeatre, le triangle se \"d\xe9forme\" pour continuer \xe0 remplir toute la fen\xeatre. Ce n'est g\xe9n\xe9ralement pas ce qu'on veut, et nous verrons comment rem\xe9dier \xe0 \xe7a ",(0,r.jsx)(s.a,{href:"#envoyer-des-param%C3%A8tres-au-shader--les-uniforms",children:"plus tard"}),"."]}),"\n",(0,r.jsx)(s.h3,{id:"renderdoc",children:"RenderDoc"}),"\n",(0,r.jsx)(s.p,{children:"Avant d'aller plus loin, nous allons commencer \xe0 d\xe9couvrir RenderDoc, un super outil qui nous permettra de d\xe9buguer si jamais notre rendu ne se fait pas comme on voudrait."}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"info",children:(0,r.jsxs)(s.p,{children:["Si jamais vous avez besoin de RenderDoc dans Unreal ou Unity, c'est possible ! Vous pouvez ouvrir ces moteurs directement dans RenderDoc, mais m\xeame encore mieux il y a ",(0,r.jsx)(s.a,{href:"https://docs.unrealengine.com/4.27/en-US/TestingAndOptimization/PerformanceAndProfiling/RenderDoc/",children:"un plugin RenderDoc pour Unreal"}),", et le ",(0,r.jsx)(s.a,{href:"https://youtu.be/4N8GxCeolzM",children:"Frame Debugger pour Unity"})," qui est un \xe9quivalent de RenderDoc int\xe9gr\xe9 directement dans Unity."]})}),"\n",(0,r.jsxs)(s.p,{children:["La premi\xe8re chose \xe0 faire quand vous ouvrez RenderDoc, c'est d'aller dans l'onglet ",(0,r.jsx)(s.code,{children:"Launch Application"})," pour choisir l'ex\xe9cutable \xe0 d\xe9buguer (qui va se trouver dans le dossier de votre projet, et le sous-dossier build. Il devrait s'appeler ",(0,r.jsx)(s.code,{children:"TPs-Rendering.exe"}),"):"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(80).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Une fois que s'est fait, vous pouvez cliquer sur ",(0,r.jsx)(s.code,{children:"Launch"})," :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(8411).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.p,{children:'qui va lancer votre application en "mode RenderDoc" :'}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(3586).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Vous pouvez alors faire ",(0,r.jsx)("kbd",{children:"F12"})," pour capturer une frame, puis fermer l'application, et RenderDoc va vous permettre d'inspecter la frame que vous venez de capturer :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(8445).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.p,{children:"La premi\xe8re chose \xe0 regarder, c'est la timeline sur le c\xf4t\xe9, qui indique toutes les op\xe9rations OpenGL qui ont \xe9t\xe9 ex\xe9cut\xe9es pendant la frame. Vous pouvez cliquer sur chacune d'elle, et voir le rendu \xe0 ce moment l\xe0 de la frame :"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(4548).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Dans notre cas c'est tr\xe8s simple, il y a la couleur de fond qui est faite avec ",(0,r.jsx)(s.code,{children:"glClear"}),", puis le draw call de notre mesh avec ",(0,r.jsx)(s.code,{children:"glDrawArrays"})," (le 3 indique qu'il y avait 3 sommets dans notre vertex buffer)."]}),"\n",(0,r.jsxs)(s.p,{children:["Ensuite on peut inspecter chaque \xe9tape du rendu en cliquant dessus. Ce qui va nous int\xe9resser c'est le draw call de notre mesh, donc cliquez sur l'\xe9tape ",(0,r.jsx)(s.code,{children:"glDrawArrays"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["La premi\xe8re chose \xe0 faire, si typiquement votre mesh ne s'affiche pas, c'est d'aller dans ",(0,r.jsx)(s.code,{children:"Overlay"}),", et de s\xe9lectionner ",(0,r.jsx)(s.code,{children:"Highlight Drawcall"}),". \xc7a va indiquer l\xe0 o\xf9 votre mesh a atterri \xe0 l'\xe9cran."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(1407).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Si vous voyez bien votre mesh en magenta dans le draw call, mais qu'ensuite le triangle ne s'affiche pas, c'est d\xe9j\xe0 une tr\xe8s bonne information ! Dans ce cas vous pouvez ensuite passer le mode d'overlay en ",(0,r.jsx)(s.code,{children:"Depth Test"}),", puis ",(0,r.jsx)(s.code,{children:"Stencil Test"}),", puis ",(0,r.jsx)(s.code,{children:"Backface Cull"}),". Si l'un d'eux affiche votre mesh en rouge, c'est que cette \xe9tape du rasterizer a d\xe9cid\xe9 de skipper votre mesh. Nous reparlerons de ces \xe9tapes plus tard (",(0,r.jsx)(s.a,{href:"#depth-buffer",children:"Depth Test"}),", ",(0,r.jsx)(s.a,{href:"TODO",children:"Stencil Test"}),", ",(0,r.jsx)(s.a,{href:"TODO",children:"Backface Culling"}),"). Sinon, si tout est vert mais que votre mesh ne s'affiche quand m\xeame pas, c'est probablement au niveau du fragment shader qu'il y a un probl\xe8me."]}),"\n",(0,r.jsxs)(s.p,{children:["Si \xe0 l'inverse d\xe8s l'overlay ",(0,r.jsx)(s.code,{children:"Highlight Drawcall"})," vous ne voyez pas votre mesh, alors c'est le mesh lui-m\xeame qui a un probl\xe8me. Vous pouvez alors aller dans l'onglet ",(0,r.jsx)(s.code,{children:"Mesh Viewer"})," :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(4470).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Ici vous avez plein d'informations : d'abord la vue ",(0,r.jsx)(s.code,{children:"VS In"})," vous montre votre mesh tel qu'il \xe9tait avant le vertex shader :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(1777).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Si votre mesh appara\xeet bien ici, tant mieux ! Et sinon, c'est probablement que votre vertex buffer n'est pas bon ! Vous pouvez inspecter votre vertex buffer dans la vue ",(0,r.jsx)(s.code,{children:"VS Input"}),", et regarder si il y a des valeurs bizarres / pas assez de vertexs / un layout qui ne correspond pas \xe0 ce que vous pensiez avoir sp\xe9cifi\xe9, etc. Dans cet example, on voit que tout va bien, et on retrouve les valeurs qu'on avait mises dans notre vertex buffer :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(1560).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Ensuite, vous pouvez aller voir dans ",(0,r.jsx)(s.code,{children:"VS Out"})," l'\xe9tat de votre mesh apr\xe8s le vertex shader. Dans les sections suivantes nous appliquerons des transformations au mesh dans le vertex shader (d\xe9placement, cam\xe9ra, etc.), et vous pourrez voir le r\xe9sultat ici :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(4110).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Et une fois de plus, si vous avez besoin d'inspecter les valeurs pr\xe9cises, elles sont toutes dans la vue ",(0,r.jsx)(s.code,{children:"VS Output"})," :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(3607).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.p,{children:"RenderDoc permet encore beaucoup d'autres choses, mais vous avez vu l'essentiel qui vous sauvera 99% du temps !"}),"\n",(0,r.jsx)(s.h3,{id:"dessiner-un-rectangle",children:"Dessiner un rectangle"}),"\n",(0,r.jsx)(s.p,{children:"Maintenant, \xe0 vous de jouer ! Modifiez le code qui cr\xe9e votre mesh afin d'avoir non plus un triangle, mais un rectangle qui prendra la moiti\xe9 de l'\xe9cran. Il vous faudra dessiner deux triangles, et donc indiquer six sommets dans le vertex buffer."}),"\n",(0,r.jsx)(s.p,{children:"Si vous avez un probl\xe8me de rendu, pensez \xe0 aller voir dans RenderDoc ce qu'il se passe !"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(1215).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.h3,{id:"index-buffer",children:"Index buffer"}),"\n",(0,r.jsxs)(s.p,{children:["Vous avez peut-\xeatre remarqu\xe9 une chose en faisant le vertex buffer du rectangle, c'est que vous avez d\xfb \xe9crire certains sommets deux fois ! (Une fois pour dessiner le premier triangle, puis une deuxi\xe8me fois pour le deuxi\xe8me triangle). Et d'ailleurs, six sommets pour un rectangle \xe7a fait beaucoup, 4 devraient suffire !",(0,r.jsx)("br",{}),"\nC'est un probl\xe8me qui devient d'autant plus emb\xeatant que sur un vrai mesh les sommets sont parfois partag\xe9s par bien plus que deux triangles, et donc doivent \xeatre dupliqu\xe9s plein de fois, ce qui augmente consid\xe9rablement la taille du mesh."]}),"\n",(0,r.jsxs)(s.p,{children:["Heureusement, ce probl\xe8me a une solution : l'",(0,r.jsx)(s.strong,{children:"index buffer"})," !"]}),"\n",(0,r.jsxs)(s.p,{children:["Quand on cr\xe9e notre ",(0,r.jsx)(s.code,{children:"gl::Mesh"})," on peut, en plus du vertex buffer, sp\xe9cifier un index buffer :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"auto const rectangle_mesh = gl::Mesh{{\n    .vertex_buffers = {{\n        .layout = {gl::VertexAttribute::Position2D{0}},\n        .data   = {\n            -0.5f, -0.5f, // Position2D du 1er sommet\n            +0.5f, -0.5f, // Position2D du 2\xe8me sommet\n            +0.5f, +0.5f, // Position2D du 3\xe8me sommet\n            -0.5f, +0.5f  // Position2D du 4\xe8me sommet\n        },\n    }},\n    .index_buffer   = {\n        0, 1, 2, // Indices du premier triangle : on utilise le 1er, 2\xe8me et 3\xe8me sommet\n        0, 2, 3  // Indices du deuxi\xe8me triangle : on utilise le 1er, 3\xe8me et 4\xe8me sommet\n    },\n}};\n"})}),"\n",(0,r.jsx)(s.p,{children:"Les indices dans l'index buffer vont par 3, et d\xe9crivent un triangle en indiquant quels sommets prendre dans le vertex buffer."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(1215).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.p,{children:"Le rendu est exactement le m\xeame, mais notre vertex buffer est plus simple \xe0 \xe9crire, et plus l\xe9ger pour l'ordinateur !"}),"\n",(0,r.jsxs)(s.p,{children:["Vous allez pouvoir tester d'\xe9crire vous-m\xeame un index buffer ",(0,r.jsx)(s.a,{href:"#cube",children:"quand vous ferez un cube"}),", mais avant cela il nous manque quelques \xe9tapes pour passer en 3D !"]}),"\n",(0,r.jsx)(s.h2,{id:"shader",children:"Shader"}),"\n",(0,r.jsxs)(s.p,{children:["Un ",(0,r.jsx)(s.strong,{children:"Shader"})," est un programme ex\xe9cut\xe9 par la carte graphique. Il existe deux principaux types de shaders :"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Le ",(0,r.jsx)(s.strong,{children:"Vertex Shader"})," qui prend un sommet dans notre vertex buffer et le modifie (d\xe9placement, application de la perspective 3D, etc.)"]}),"\n",(0,r.jsxs)(s.li,{children:["Le ",(0,r.jsx)(s.strong,{children:"Fragment Shader"})," qui prend un pixel de notre triangle et le colorie (en fonction de son mat\xe9riau, de la lumi\xe8re, etc.)"]}),"\n"]}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"info",children:(0,r.jsxs)(s.p,{children:["Il existe aussi les ",(0,r.jsx)(s.strong,{children:"Compute Shaders"})," qui sont plus g\xe9n\xe9riques et prennent n'importe quel type de buffer et le modifient. Ils sont tr\xe8s utilis\xe9s pour faire des simulations sur GPU (particules, fluides, v\xeatements, etc.)."]})}),"\n",(0,r.jsx)(s.p,{children:"Pour cr\xe9er un shader, il vous suffit de faire, dans l'initialisation :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'auto const shader = gl::Shader{{\n    .vertex   = gl::ShaderSource::File{"res/vertex.glsl"},\n    .fragment = gl::ShaderSource::File{"res/fragment.glsl"},\n}};\n'})}),"\n",(0,r.jsxs)(s.p,{children:["et de cr\xe9er les deux fichiers correspondants, dans le dossier ",(0,r.jsx)(s.em,{children:"res"})," :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",metastring:'title="res/vertex.glsl"',children:"#version 410\n\nlayout(location = 0) in vec2 in_position;\n\nvoid main()\n{\n    gl_Position = vec4(in_position, 0., 1.);\n}\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",metastring:'title="res/fragment.glsl"',children:"#version 410\n\nout vec4 out_color;\n\nvoid main()\n{\n    out_color = vec4(1.);\n}\n"})}),"\n",(0,r.jsx)(s.admonition,{title:"IMPORTANT",type:"info",children:(0,r.jsxs)(s.p,{children:["Tous les assets (shader, texture, mod\xe8le 3D, etc.) doivent \xeatre mis dans le dossier ",(0,r.jsx)(s.code,{children:"res"}),", ",(0,r.jsx)(s.strong,{children:"et pas un autre"}),", car ce dossier est copi\xe9 pour \xeatre mis \xe0 c\xf4t\xe9 de l'exe dans le dossier build. (C'est fait dans le CMakeLists.txt, par la ligne ",(0,r.jsx)(s.code,{children:"gl_target_copy_folder(${PROJECT_NAME} res)"}),"). Si jamais vous vouliez renommer le dossier ",(0,r.jsx)(s.em,{children:"res"})," ou en ajouter un autre, il faudrait bien penser \xe0 aller modifier le CMakeLists.txt !"]})}),"\n",(0,r.jsxs)(s.p,{children:["Puis pour utiliser ce shader \xe0 la place du shader par d\xe9faut, remplacez la ligne ",(0,r.jsx)(s.code,{children:"gl::bind_default_shader();"})," par ",(0,r.jsx)(s.code,{children:"shader.bind();"})," :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(1215).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.p,{children:"Le rendu n'a toujours pas chang\xe9, car les shaders que je vous ai donn\xe9s sont \xe9quivalents aux shaders par d\xe9faut qu'on utilisait jusque l\xe0. Mais \xe7a ne saurait tarder, nous allons maintenant pouvoir modifier nos shaders comme on veut ! Mais avant tout, quelques explications :"}),"\n",(0,r.jsx)(s.h3,{id:"glsl",children:"GLSL"}),"\n",(0,r.jsxs)(s.p,{children:["D\xe9j\xe0, le GLSL est le langage utilis\xe9 pour \xe9crire des shaders. Il ressemble tr\xe8s fort \xe0 du C, avec en plus quelques fonctions et types tr\xe8s souvent utilis\xe9s en rendu 3D : vecteurs (",(0,r.jsx)(s.code,{children:"vec2"}),", ",(0,r.jsx)(s.code,{children:"vec3"}),", ",(0,r.jsx)(s.code,{children:"vec4"}),"), matrices (",(0,r.jsx)(s.code,{children:"mat2"}),", ",(0,r.jsx)(s.code,{children:"mat3"}),", ",(0,r.jsx)(s.code,{children:"mat4"}),"), et fonctions g\xe9om\xe9triques (produit scalaire ",(0,r.jsx)(s.code,{children:"dot(v1, v2)"}),", normalisation d'un vecteur ",(0,r.jsx)(s.code,{children:"normalize(v)"}),", etc.)."]}),"\n",(0,r.jsxs)(s.p,{children:["Chaque shader doit commencer par une indication de la version utilis\xe9e (",(0,r.jsx)(s.code,{children:"#version 410"}),"). Nous utilisons la 410, qui est la derni\xe8re support\xe9e par MacOS. (Et sinon elles vont jusqu'\xe0 460, mais il n'y a aucune diff\xe9rence en ce qui nous concerne)."]}),"\n",(0,r.jsx)(s.h3,{id:"vertex-shader",children:"Vertex Shader"}),"\n",(0,r.jsx)(s.p,{children:"Le vertex shader commence par une d\xe9claration des attributs :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",children:"layout(location = 0) in vec2 in_position;\n"})}),"\n",(0,r.jsx)(s.p,{children:"Ces attributs doivent correspondre au layout de notre vertex buffer :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:".vertex_buffers = {{\n    .layout = {gl::VertexAttribute::Position2D{0 /*Index de l'attribut dans le shader*/}},\n    .data   = {\n        // ...\n    },\n}},\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Le ",(0,r.jsx)(s.code,{children:"layout(location = 0)"})," correspond \xe0 l'index ",(0,r.jsx)(s.code,{children:"0"})," sp\xe9cifi\xe9 pour ",(0,r.jsx)(s.code,{children:"gl::VertexAttribute::Position2D"}),", et le type ",(0,r.jsx)(s.code,{children:"vec2"})," vient du fait que nos positions 2D sont des vecteurs \xe0 deux composantes (si on utilisait des positions 3D, il faudrait mettre ",(0,r.jsx)(s.code,{children:"vec3"}),"). Le nom ",(0,r.jsx)(s.code,{children:"in_position"})," est libre et vous pouvez mettre ce que vous voulez."]}),"\n",(0,r.jsxs)(s.p,{children:["Ensuite, dans la fonction ",(0,r.jsx)(s.code,{children:"main()"})," on assigne la variable ",(0,r.jsx)(s.code,{children:"gl_Position"}),", qui est une variable sp\xe9ciale indiquant \xe0 OpenGL la position finale du vertex (ce qui correspond au ",(0,r.jsx)(s.code,{children:"VS Out"})," qu'on avait vu dans RenderDoc)."]}),"\n",(0,r.jsxs)(s.p,{children:["En guise de premier exercice, vous pouvez d\xe9placer le rectangle via le vertex shader, par exemple de ",(0,r.jsx)(s.code,{children:"0.4"})," en x et en y :"]}),"\n",(0,r.jsxs)(s.admonition,{type:"tip",children:[(0,r.jsxs)(s.p,{children:["Vous ne pouvez pas modifier la variable ",(0,r.jsx)(s.code,{children:"in_position"})," car elle vient du vertex buffer, et modifier le vertex buffer n'est pas autoris\xe9 dans le vertex shader. \xc0 la place, cr\xe9ez une copie :"]}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",children:"#version 410\n\nlayout(location = 0) in vec2 in_position;\n\nvoid main()\n{\n    // highlight-next-line\n    vec2 position = in_position;\n    // ...\n    // Modifiez `position` comme vous voulez\n    // ...\n    // highlight-next-line\n    gl_Position = vec4(position, 0., 1.); // Ici on utilise maintenant `position` et non plus `in_position`\n}\n"})})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(2198).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.h3,{id:"fragment-shader",children:"Fragment Shader"}),"\n",(0,r.jsx)(s.p,{children:"Le fragment shader commence par"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",children:"out vec4 out_color;\n"})}),"\n",(0,r.jsx)(s.p,{children:"qui d\xe9clare la variable de sortie : ce qu'on assigne \xe0 cette variable correspondra \xe0 la couleur du pixel \xe0 l'\xe9cran."}),"\n",(0,r.jsxs)(s.p,{children:["Et dans le ",(0,r.jsx)(s.code,{children:"main()"})," on fait quelque chose de tr\xe8s simple, qui est d'assigner la m\xeame couleur \xe0 tous les pixels, sans r\xe9fl\xe9chir :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",children:"out_color = vec4(1.);\n"})}),"\n",(0,r.jsx)(s.admonition,{title:"Note",type:"tip",children:(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["La syntaxe ",(0,r.jsx)(s.code,{children:"vec4(1.)"})," est un raccourci pour ",(0,r.jsx)(s.code,{children:"vec4(1., 1., 1., 1.)"}),". On peut m\xeame faire des choses comme ",(0,r.jsx)(s.code,{children:"vec4(vec3(0.5), 1.)"}),", qui revient \xe0 faire ",(0,r.jsx)(s.code,{children:"vec4(0.5, 0.5, 0.5, 1.)"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["Les composantes R, G, B et A des couleurs vont de 0 \xe0 1, donc ",(0,r.jsx)(s.code,{children:"vec3(1., 1., 1.)"})," correspond \xe0 mettre le maximum de rouge, vert et bleu, donc du blanc pur."]}),"\n"]})}),"\n",(0,r.jsx)(s.p,{children:"En guise de premier exercice, vous pouvez changer la couleur du rectangle :"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(9757).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.h3,{id:"envoyer-des-param\xe8tres-au-shader--les-uniforms",children:"Envoyer des param\xe8tres au shader : les uniforms"}),"\n",(0,r.jsxs)(s.p,{children:["Pour que nos shaders deviennent int\xe9ressants, il faut leur envoyer plus de donn\xe9es en entr\xe9e. On peut soit rajouter des attributs dans le vertex buffer (couleur, UV, normale, etc.), ",(0,r.jsx)(s.a,{href:"TODO",children:"ce que nous verrons plus tard"})," ; soit envoyer des param\xe8tres appel\xe9s ",(0,r.jsx)(s.code,{children:"uniforms"}),". Une variable uniforme se d\xe9clare ainsi dans le shader, au-dessus du ",(0,r.jsx)(s.code,{children:"main()"})," :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",children:"uniform vec2 nom_de_votre_variable_uniforme; // Vous pouvez mettre le type que vous voulez, et le nom que vous voulez\n"})}),"\n",(0,r.jsx)(s.p,{children:"puis peut s'utiliser dans votre shader comme vous le voulez, comme n'importe quelle variable normale."}),"\n",(0,r.jsx)(s.p,{children:"Pour assigner la valeur d'une variable uniforme, cela se fait dans votre code C++, apr\xe8s avoir bind le shader :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'shader.set_uniform("nom_de_votre_variable_uniforme", glm::vec2{1.f, 3.f});\n'})}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"tip",children:(0,r.jsxs)(s.p,{children:["On utilise la librairie ",(0,r.jsx)(s.code,{children:"glm"})," pour avoir des types vecteur et matrice comme en glsl : ",(0,r.jsx)(s.code,{children:"glm::vec2"}),", ",(0,r.jsx)(s.code,{children:"glm::vec3"}),", ",(0,r.jsx)(s.code,{children:"glm::vec4"}),", ",(0,r.jsx)(s.code,{children:"glm::mat2"}),", ",(0,r.jsx)(s.code,{children:"glm::mat3"}),", ",(0,r.jsx)(s.code,{children:"glm::mat4"}),", etc."]})}),"\n",(0,r.jsx)(s.admonition,{title:"Note",type:"info",children:(0,r.jsxs)(s.p,{children:["Une variable ",(0,r.jsx)(s.code,{children:"uniform"})," s'appelle ainsi car elle est uniforme pour un draw call : \xe7a sera la m\xeame pour tous les vertexs et pour tous les pixels lors d'un appel donn\xe9 \xe0 ",(0,r.jsx)(s.code,{children:"mesh.draw()"}),".",(0,r.jsx)("br",{}),"\nSi on voulait une valeur qui est diff\xe9rente pour chaque vertex, il faudrait passer par un attribut de vertex."]})}),"\n",(0,r.jsxs)(s.p,{children:["On peut par exemple utiliser les uniforms pour r\xe9gler ",(0,r.jsx)(s.a,{href:"#vertex-buffer-et-premier-triangle",children:"notre probl\xe8me de taille de rectangle qui suit la fen\xeatre"}),". Pour cela, nous allons passer au shader ",(0,r.jsx)(s.strong,{children:"l'aspect ratio"})," de la fen\xeatre (i.e. ",(0,r.jsx)(s.code,{children:"largeur / hauteur"}),"), et corriger la position en x de nos vertexs en fonction du ratio."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["D\xe9clarez une uniform ",(0,r.jsx)(s.code,{children:"aspect_ratio"})," de type ",(0,r.jsx)(s.code,{children:"float"})," dans le vertex shader"]}),"\n",(0,r.jsxs)(s.li,{children:["Divisez le x de la position de votre vertex par ",(0,r.jsx)(s.code,{children:"aspect_ratio"})]}),"\n",(0,r.jsxs)(s.li,{children:["C\xf4t\xe9 C++, passez la uniform au shader (Vous pouvez obtenir l'aspect ratio de la fen\xeatre avec ",(0,r.jsx)(s.code,{children:"gl::framebuffer_aspect_ratio()"}),")"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{src:n(6724).A+"",width:"1920",height:"1030"}),"\n",(0,r.jsx)(s.em,{children:"Enfin un carr\xe9 qui reste carr\xe9 peu importe la taille de la fen\xeatre !"})]}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"tip",children:(0,r.jsx)(s.p,{children:"On pourrait se dire qu'il suffisait de cr\xe9er un nouveau vertex buffer avec des positions qui prennent en compte l'aspect ratio, et de recr\xe9er le buffer \xe0 chaque fois que l'aspect ratio change. Mais \xe7a impliquerait de modifier potentiellement les millions de vertexs de notre mesh, ce qui prendrait beaucoup de temps. Alors que le vertex shader lui va faire \xe7a en un rien de temps : c'est la puissance de la carte graphique, qui peut traiter tous les sommets en parall\xe8le extr\xeamement vite !"})}),"\n",(0,r.jsx)(s.h3,{id:"exercice--faire-bouger-le-carr\xe9",children:"Exercice : Faire bouger le carr\xe9"}),"\n",(0,r.jsxs)(s.p,{children:["Vous pouvez utiliser ",(0,r.jsx)(s.code,{children:"gl::time_in_seconds()"})," pour r\xe9cup\xe9rer le temps, l'envoyer au shader, et vous en servir pour faire bouger le carr\xe9. Le plus simple est de le faire aller en ligne droite, mais vous pouvez aussi (bonus) le faire aller et revenir, ou tourner en rond :"]}),"\n",(0,r.jsx)(s.table,{children:(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:(0,r.jsx)(s.img,{src:n(2965).A+"",width:"1905",height:"988"})}),(0,r.jsx)(s.th,{children:(0,r.jsx)(s.img,{src:n(8380).A+"",width:"1905",height:"988"})}),(0,r.jsx)(s.th,{children:(0,r.jsx)(s.img,{src:n(6147).A+"",width:"1905",height:"988"})})]})})}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"tip",children:(0,r.jsxs)(s.p,{children:["Maintenant qu'on a un objet qui bouge, on peut enfin tester ce qu'il se passe quand on enl\xe8ve la ligne ",(0,r.jsx)(s.code,{children:"glClear(GL_COLOR_BUFFER_BIT);"}),". Je vous laisse essayer !"]})}),"\n",(0,r.jsx)(s.h3,{id:"bonus--effet-de-fade",children:"Bonus : effet de fade"}),"\n",(0,r.jsx)(s.p,{children:"Vous avez toutes les cartes en main pour faire cet effet de fade, alors je vous laisse chercher comment faire \ud83d\ude09"}),"\n",(0,r.jsxs)(s.admonition,{title:"Info",type:"tip",children:[(0,r.jsx)(s.p,{children:"Vous aurez probablement besoin d'utiliser de la transparence \xe0 un moment, qui n\xe9cessite d'\xeatre activ\xe9e, au d\xe9but de l'initialisation, avec :"}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'glEnable(GL_BLEND);\nglBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE); // On peut configurer l\'\xe9quation qui m\xe9lange deux couleurs, comme pour faire diff\xe9rents blend mode dans Photoshop. Cette \xe9quation-ci donne le blending "normal" entre pixels transparents.\n'})})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(1161).A+"",width:"1905",height:"988"})}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"info",children:(0,r.jsxs)(s.p,{children:["Si vous voyez un effet de clignotement, c'est normal, c'est d\xfb \xe0 la swapchain : en fait il y a deux images qui s'alternent : l'une qui est affich\xe9e \xe0 l'\xe9cran, et l'autre sur laquelle on est en train de dessiner. (Si on dessinait sur l'image qui est actuellement affich\xe9e \xe0 l'\xe9cran, on verrait les pixels se dessiner petit \xe0 petit et \xe7a ferait tr\xe8s moche). Pour r\xe9soudre ce clignotement, il faudrait faire le rendu de toute notre sc\xe8ne dans une ",(0,r.jsx)(s.a,{href:"#render-target",children:"render target"})," \xe0 part, qu'on copierait \xe0 l'\xe9cran \xe0 la fin de chaque frame. Nous verrons cette notion plus tard."]})}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"info",children:(0,r.jsxs)(s.p,{children:["Il reste une trace qui ne s'efface pas, c'est d\xfb \xe0 des probl\xe8mes d'arrondi au moment du calcul de la transparence, car chaque canal de couleur est stock\xe9 sur un entier \xe0 8 bits seulement (par d\xe9faut). En faisant notre rendu sur une ",(0,r.jsx)(s.a,{href:"#render-target",children:"render target"})," utilisant 16 ou 32 bits par canal, \xe7a r\xe9soudrait le probl\xe8me."]})}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"info",children:(0,r.jsxs)(s.p,{children:["Cet effet d\xe9pend du framerate ! Si vous dessinez deux fois plus d'images par seconde, la trace va s'effacer deux fois plus vite. Pour \xe9viter cela, il faudrait prendre en compte ",(0,r.jsx)(s.code,{children:"gl::delta_time_in_seconds()"}),", qui donne le temps \xe9coul\xe9 entre deux frames."]})}),"\n",(0,r.jsx)(s.h2,{id:"cam\xe9ra-et-matrices",children:"Cam\xe9ra et Matrices"}),"\n",(0,r.jsx)(s.p,{children:"Il est temps de passer en 3D !"}),"\n",(0,r.jsx)(s.p,{children:"Pour cela nous avons besoin de deux informations :"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Le point de vue, i.e. savoir o\xf9 on est dans l'espace, et dans quelle direction on regarde"}),"\n",(0,r.jsx)(s.li,{children:"La projection, pour donner l'effet de perspective inh\xe9rent \xe0 la 3D"}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["Pour repr\xe9senter ces deux informations, nous allons utiliser des ",(0,r.jsx)(s.strong,{children:"matrices"}),". Une matrice est un objet math\xe9matique qui permet de repr\xe9senter une transformation g\xe9om\xe9trique. On applique une matrice \xe0 un ",(0,r.jsx)(s.strong,{children:"vecteur"})," (point ou direction, en 2D ou en 3D) pour lui appliquer la transformation g\xe9om\xe9trique repr\xe9sent\xe9e par la matrice. Par exemple on peut cr\xe9er une matrice de rotation qui, quand elle est appliqu\xe9e \xe0 un point, fait tourner ce point."]}),"\n",(0,r.jsxs)(s.admonition,{title:"Remarque",type:"info",children:[(0,r.jsxs)(s.p,{children:["Une matrice est un grille de nombre. Par exemple une matrice 3D (",(0,r.jsx)(s.code,{children:"mat3"}),") ressemblerait \xe0 :"]}),(0,r.jsx)(s.span,{className:"katex-display",children:(0,r.jsxs)(s.span,{className:"katex",children:[(0,r.jsx)(s.span,{className:"katex-mathml",children:(0,r.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,r.jsxs)(s.semantics,{children:[(0,r.jsxs)(s.mrow,{children:[(0,r.jsx)(s.mo,{fence:"true",children:"("}),(0,r.jsxs)(s.mtable,{rowspacing:"0.16em",columnalign:"center center center",columnspacing:"1em",children:[(0,r.jsxs)(s.mtr,{children:[(0,r.jsx)(s.mtd,{children:(0,r.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"false",children:(0,r.jsx)(s.mn,{children:"1"})})}),(0,r.jsx)(s.mtd,{children:(0,r.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"false",children:(0,r.jsx)(s.mn,{children:"0"})})}),(0,r.jsx)(s.mtd,{children:(0,r.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"false",children:(0,r.jsx)(s.mn,{children:"4"})})})]}),(0,r.jsxs)(s.mtr,{children:[(0,r.jsx)(s.mtd,{children:(0,r.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"false",children:(0,r.jsx)(s.mn,{children:"0"})})}),(0,r.jsx)(s.mtd,{children:(0,r.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"false",children:(0,r.jsx)(s.mn,{children:"1"})})}),(0,r.jsx)(s.mtd,{children:(0,r.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"false",children:(0,r.jsx)(s.mn,{children:"2"})})})]}),(0,r.jsxs)(s.mtr,{children:[(0,r.jsx)(s.mtd,{children:(0,r.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"false",children:(0,r.jsx)(s.mn,{children:"0"})})}),(0,r.jsx)(s.mtd,{children:(0,r.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"false",children:(0,r.jsx)(s.mn,{children:"0"})})}),(0,r.jsx)(s.mtd,{children:(0,r.jsx)(s.mstyle,{scriptlevel:"0",displaystyle:"false",children:(0,r.jsx)(s.mn,{children:"1"})})})]})]}),(0,r.jsx)(s.mo,{fence:"true",children:")"})]}),(0,r.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\begin{pmatrix}\n1 & 0 & 4 \\\\\n0 & 1 & 2 \\\\\n0 & 0 & 1\n\\end{pmatrix}"})]})})}),(0,r.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(s.span,{className:"base",children:[(0,r.jsx)(s.span,{className:"strut",style:{height:"3.6em",verticalAlign:"-1.55em"}}),(0,r.jsxs)(s.span,{className:"minner",children:[(0,r.jsx)(s.span,{className:"mopen",children:(0,r.jsx)(s.span,{className:"delimsizing mult",children:(0,r.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,r.jsxs)(s.span,{className:"vlist-r",children:[(0,r.jsx)(s.span,{className:"vlist",style:{height:"2.05em"},children:(0,r.jsxs)(s.span,{style:{top:"-4.05em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"5.6em"}}),(0,r.jsx)(s.span,{style:{width:"0.875em",height:"3.600em"},children:(0,r.jsx)(s.svg,{xmlns:"http://www.w3.org/2000/svg",width:"0.875em",height:"3.600em",viewBox:"0 0 875 3600",children:(0,r.jsx)(s.path,{d:"M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0,84c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-92c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z"})})})]})}),(0,r.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,r.jsx)(s.span,{className:"vlist-r",children:(0,r.jsx)(s.span,{className:"vlist",style:{height:"1.55em"},children:(0,r.jsx)(s.span,{})})})]})})}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsxs)(s.span,{className:"mtable",children:[(0,r.jsx)(s.span,{className:"col-align-c",children:(0,r.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,r.jsxs)(s.span,{className:"vlist-r",children:[(0,r.jsxs)(s.span,{className:"vlist",style:{height:"2.05em"},children:[(0,r.jsxs)(s.span,{style:{top:"-4.21em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsx)(s.span,{className:"mord",children:"1"})})]}),(0,r.jsxs)(s.span,{style:{top:"-3.01em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsx)(s.span,{className:"mord",children:"0"})})]}),(0,r.jsxs)(s.span,{style:{top:"-1.81em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsx)(s.span,{className:"mord",children:"0"})})]})]}),(0,r.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,r.jsx)(s.span,{className:"vlist-r",children:(0,r.jsx)(s.span,{className:"vlist",style:{height:"1.55em"},children:(0,r.jsx)(s.span,{})})})]})}),(0,r.jsx)(s.span,{className:"arraycolsep",style:{width:"0.5em"}}),(0,r.jsx)(s.span,{className:"arraycolsep",style:{width:"0.5em"}}),(0,r.jsx)(s.span,{className:"col-align-c",children:(0,r.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,r.jsxs)(s.span,{className:"vlist-r",children:[(0,r.jsxs)(s.span,{className:"vlist",style:{height:"2.05em"},children:[(0,r.jsxs)(s.span,{style:{top:"-4.21em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsx)(s.span,{className:"mord",children:"0"})})]}),(0,r.jsxs)(s.span,{style:{top:"-3.01em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsx)(s.span,{className:"mord",children:"1"})})]}),(0,r.jsxs)(s.span,{style:{top:"-1.81em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsx)(s.span,{className:"mord",children:"0"})})]})]}),(0,r.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,r.jsx)(s.span,{className:"vlist-r",children:(0,r.jsx)(s.span,{className:"vlist",style:{height:"1.55em"},children:(0,r.jsx)(s.span,{})})})]})}),(0,r.jsx)(s.span,{className:"arraycolsep",style:{width:"0.5em"}}),(0,r.jsx)(s.span,{className:"arraycolsep",style:{width:"0.5em"}}),(0,r.jsx)(s.span,{className:"col-align-c",children:(0,r.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,r.jsxs)(s.span,{className:"vlist-r",children:[(0,r.jsxs)(s.span,{className:"vlist",style:{height:"2.05em"},children:[(0,r.jsxs)(s.span,{style:{top:"-4.21em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsx)(s.span,{className:"mord",children:"4"})})]}),(0,r.jsxs)(s.span,{style:{top:"-3.01em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsx)(s.span,{className:"mord",children:"2"})})]}),(0,r.jsxs)(s.span,{style:{top:"-1.81em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,r.jsx)(s.span,{className:"mord",children:(0,r.jsx)(s.span,{className:"mord",children:"1"})})]})]}),(0,r.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,r.jsx)(s.span,{className:"vlist-r",children:(0,r.jsx)(s.span,{className:"vlist",style:{height:"1.55em"},children:(0,r.jsx)(s.span,{})})})]})})]})}),(0,r.jsx)(s.span,{className:"mclose",children:(0,r.jsx)(s.span,{className:"delimsizing mult",children:(0,r.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,r.jsxs)(s.span,{className:"vlist-r",children:[(0,r.jsx)(s.span,{className:"vlist",style:{height:"2.05em"},children:(0,r.jsxs)(s.span,{style:{top:"-4.05em"},children:[(0,r.jsx)(s.span,{className:"pstrut",style:{height:"5.6em"}}),(0,r.jsx)(s.span,{style:{width:"0.875em",height:"3.600em"},children:(0,r.jsx)(s.svg,{xmlns:"http://www.w3.org/2000/svg",width:"0.875em",height:"3.600em",viewBox:"0 0 875 3600",children:(0,r.jsx)(s.path,{d:"M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,9\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-144c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z"})})})]})}),(0,r.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,r.jsx)(s.span,{className:"vlist-r",children:(0,r.jsx)(s.span,{className:"vlist",style:{height:"1.55em"},children:(0,r.jsx)(s.span,{})})})]})})})]})]})})]})}),(0,r.jsxs)(s.p,{children:["Je ne rentrerai pas dans les d\xe9tails de quels nombres mettre dans la matrice pour repr\xe9senter quelle transformation, car nous allons utiliser la librairie ",(0,r.jsx)(s.code,{children:"glm"})," pour cr\xe9er toutes ces matrices."]})]}),"\n",(0,r.jsxs)(s.p,{children:["Le gros int\xe9r\xeat des matrices est qu'on peut les combiner entre elles en les multipliant ! Par exemple si j'ai une matrice 3D de rotation ",(0,r.jsx)(s.code,{children:"R"})," et une matrice 3D de translation ",(0,r.jsx)(s.code,{children:"T"}),", alors ",(0,r.jsx)(s.code,{children:"R * T"})," est une nouvelle matrice 3D, dont la transformation g\xe9om\xe9trique est une translation suivie d'une rotation (",(0,r.jsx)(s.strong,{children:"NB :"})," la transformation de droite est appliqu\xe9e en premi\xe8re)."]}),"\n",(0,r.jsxs)(s.p,{children:["On peut ainsi construire une seule matrice finale, repr\xe9sentant la combinaison du point de vue (",(0,r.jsx)(s.strong,{children:"view matrix"}),") et de la projection (",(0,r.jsx)(s.strong,{children:"projection matrix"}),"). On peut aussi y rajouter une modification de notre mesh (pour faire tourner le mesh, le translater pour le positionner dans le monde o\xf9 on veut, etc.) (",(0,r.jsx)(s.strong,{children:"model matrix"}),"). Ensuite on envoie cette seule matrice au shader, il l'applique \xe0 la position de nos vertexs, et le tour est jou\xe9 !"]}),"\n",(0,r.jsx)(s.admonition,{title:"Attention",type:"tip",children:(0,r.jsxs)(s.p,{children:["L'ordre des matrices a son importance ! ",(0,r.jsx)(s.code,{children:"R * T"})," est diff\xe9rent de ",(0,r.jsx)(s.code,{children:"T * R"}),".",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.code,{children:"T * R"})," est une rotation suivie d'une translation, ce qui est diff\xe9rent de d'abord faire la translation puis la rotation, comme vous pourrez le constater ",(0,r.jsx)(s.a,{href:"#exercice--model-matrix",children:"dans l'exercice qui suit"}),"."]})}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"info",children:(0,r.jsxs)(s.p,{children:["On ne peut pas repr\xe9senter n'importe quelle transformation g\xe9om\xe9trique avec des matrices, seulement celles qui sont affines. Mais c'est d\xe9j\xe0 bien assez, car les translations, les rotations et les aggrandisements sont toutes des transformations affines.",(0,r.jsx)("br",{}),"\nVous pouvez ",(0,r.jsx)(s.a,{href:"https://www.geogebra.org/m/tn9jqqdt",children:"tester cette d\xe9mo interactive"})," pour voir quel genre de transformation g\xe9om\xe9trique une matrice peut produire, et aussi regarder ",(0,r.jsx)(s.a,{href:"https://youtu.be/kYB8IZa5AuE?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab",children:"cette excellentissime vid\xe9o"}),"."]})}),"\n",(0,r.jsx)(s.h3,{id:"view-matrix",children:"View Matrix"}),"\n",(0,r.jsxs)(s.p,{children:["Pour obtenir la ",(0,r.jsx)(s.strong,{children:"View Matrix"})," nous allons utiliser une ",(0,r.jsx)(s.strong,{children:"cam\xe9ra"}),", que nous pourrons contr\xf4ler pour se d\xe9placer dans le monde :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"// Dans l'initialisation\nauto camera = gl::Camera{};\n"})}),"\n",(0,r.jsx)(s.p,{children:"puis, pour que la cam\xe9ra puisse r\xe9agir aux \xe9v\xe8nements (clic, d\xe9placement de la souris, etc.), il faut la connecter aux \xe9v\xe8nements fournis par la librairie gl :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"// Dans l'initialisation\ngl::set_events_callbacks({camera.events_callbacks()});\n"})}),"\n",(0,r.jsx)(s.p,{children:"Une fois que c'est fait, on peut r\xe9cup\xe9rer la matrice de vue avec :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"// \xc0 chaque frame\nglm::mat4 const view_matrix = camera.view_matrix();\n"})}),"\n",(0,r.jsxs)(s.admonition,{title:"Remarque",type:"tip",children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"gl::set_events_callbacks()"})," prend un tableau de callbacks, donc on pourrait rajouter nos propres callbacks en plus de ceux de la cam\xe9ra :"]}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'gl::set_events_callbacks({\n    camera.events_callbacks(),\n    {\n        .on_mouse_pressed = [&](gl::MousePressedEvent const& e) {\n            std::cout << "Mouse pressed at " << e.position.x << " " << e.position.y << \'\\n\';\n        },\n    },\n});\n'})})]}),"\n",(0,r.jsx)(s.h3,{id:"projection-matrix",children:"Projection Matrix"}),"\n",(0,r.jsx)(s.p,{children:"Il nous faut encore la matrice de projection. Celle-ci est plus simple et s'obtient directement gr\xe2ce \xe0 glm :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"glm::mat4 const projection_matrix = glm::infinitePerspective(1.f /*field of view in radians*/, gl::framebuffer_aspect_ratio() /*aspect ratio*/, 0.001f /*near plane*/);\n"})}),"\n",(0,r.jsxs)(s.p,{children:["(Attention, il faudra inclure le bon fichier de ",(0,r.jsx)(s.code,{children:"glm"})," au d\xe9but de ",(0,r.jsx)(s.em,{children:"main.cpp"})," : ",(0,r.jsx)(s.code,{children:'#include "glm/ext/matrix_clip_space.hpp"'}),")"]}),"\n",(0,r.jsx)(s.p,{children:"Ses diff\xe9rents param\xe8tres sont :"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Le ",(0,r.jsx)(s.strong,{children:"field of view"})," (angle de vue). Vous avez peut-\xeatre d\xe9j\xe0 vu ce param\xe8tre dans des jeux vid\xe9os. Plus il est large, plus on voit une grande partie de la sc\xe8ne \xe0 la fois (attention, avec des valeurs trop grande les objets commencent \xe0 appara\xeetre d\xe9form\xe9s), plus il est petit moins on voit une grande portion de la sc\xe8ne, \xe7a zoom. Attention, il est exprim\xe9 en radians, donc pour un fov de 45\xb0 il faudra \xe9crire ",(0,r.jsx)(s.code,{children:"glm::radians(45.f)"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["L'",(0,r.jsx)(s.strong,{children:"aspect ratio"})," de la fen\xeatre. La petite division par aspect_ratio qu'on avait fait ",(0,r.jsx)(s.a,{href:"#envoyer-des-param%C3%A8tres-au-shader--les-uniforms",children:"pr\xe9c\xe9demment"})," pour corriger notre probl\xe8me de stretch est g\xe9r\xe9e automatiquement par la matrice de projection, vous pouvez donc enlever cette ligne du vertex shader."]}),"\n",(0,r.jsxs)(s.li,{children:["Le ",(0,r.jsx)(s.strong,{children:"near plane"})," : \xe0 cause de limitations techniques, les objets trop proches de la cam\xe9ra ne peuvent pas \xeatre visibles. Le near plane d\xe9finit \xe0 partir de quelle distance on commence \xe0 voir les objets. Plus on le met proche de 0, plus on \xe9vitera d'avoir des objets coup\xe9s, mais si on le met trop petit on peut commencer \xe0 avoir des erreurs d'arrondis dans nos calculs entre ",(0,r.jsx)(s.code,{children:"float"}),", ce qui causerait d'autres probl\xe8mes dans notre rendu."]}),"\n",(0,r.jsxs)(s.li,{children:["Le ",(0,r.jsx)(s.strong,{children:"far plane"})," : on n'en a pas ici car on utilise ",(0,r.jsx)(s.code,{children:"glm::infinitePerspective()"}),", mais si on utilisait ",(0,r.jsx)(s.code,{children:"glm::perspective()"})," on en aurait un. Similaire au near plane, il d\xe9finit la distance \xe0 partir de laquelle on ne voit plus les objets."]}),"\n"]}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"tip",children:(0,r.jsxs)(s.p,{children:["Il y a aussi un autre type de projection : ",(0,r.jsx)(s.strong,{children:"la projection orthographique"}),". Elle ne fait pas intervenir de perspective, donc les objets lointains apparaissent \xe0 la m\xeame taille que les objets proches. Ce n'est pas r\xe9aliste, mais peut \xeatre int\xe9ressant pour donner un style au rendu."]})}),"\n",(0,r.jsx)(s.h3,{id:"envoyer-au-shader",children:"Envoyer au shader"}),"\n",(0,r.jsxs)(s.p,{children:["Maintenant qu'on a ces deux matrices, on peut les multiplier entre elles pour former la ",(0,r.jsx)(s.code,{children:"view_projection_matrix"})," (\u26a0 Attention, la view doit s'appliquer en premier, et la projection en deuxi\xe8me ! R\xe9fl\xe9chissez donc bien \xe0 l'ordre dans lequel vous multipliez vos matrices), et envoyer cette view_projection matrix au shader (d\xe9clarez une uniform de type ",(0,r.jsx)(s.code,{children:"mat4"}),"). Enfin, il ne reste plus qu'\xe0 multiplier dans le shader la matrice \xe0 la position de nos vertexs :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"gl_Position = view_projection_matrix * vec4(in_position, 0., 1.);\n"})}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"info",children:(0,r.jsxs)(s.p,{children:["Nos matrices sont des ",(0,r.jsx)(s.code,{children:"mat4"})," alors qu'on est en 3D. C'est parce qu'on utilise une \"astuce\" qui sont les ",(0,r.jsx)(s.em,{children:"coordonn\xe9es homog\xe8nes"}),", et sans lesquelles on ne pourrait pas faire de translation ni de perspective. C'est pour \xe7a qu'on a besoin de rajouter une coordonn\xe9e de plus que la dimension de l'espace. C'est aussi pour \xe7a qu'on rajoute un 1 en quatri\xe8me coordonn\xe9e de nos positions (",(0,r.jsx)(s.code,{children:"vec4(in_position, 0., 1.)"}),")."]})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(527).A+"",width:"1905",height:"988"})}),"\n",(0,r.jsx)(s.h3,{id:"exercice--param\xe8tres-de-la-projection",children:"Exercice : param\xe8tres de la projection"}),"\n",(0,r.jsx)(s.p,{children:"Essayez de changer les param\xe8tres de la matrice de projection (field of view, near plane) et essayez d'observer la diff\xe9rence de rendu. Essayez aussi d'utiliser une projection orthographique. (Je vous laisse chercher en ligne comment on fait \xe7a avec glm)."}),"\n",(0,r.jsx)(s.h3,{id:"exercice--model-matrix",children:"Exercice : model matrix"}),"\n",(0,r.jsxs)(s.p,{children:["On peut rajouter un troisi\xe8me matrice \xe0 la ",(0,r.jsx)(s.code,{children:"view_projection_matrix"}),", pour former la ",(0,r.jsx)(s.code,{children:"model_view_projection_matrix"})," ! (Attention, la model matrix doit s'appliquer en premier)."]}),"\n",(0,r.jsxs)(s.p,{children:["Avec ",(0,r.jsx)(s.code,{children:"glm"})," vous pouvez cr\xe9er une matrice de rotation avec"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"glm::mat4 const rotation = glm::rotate(glm::mat4{1.f}, gl::time_in_seconds() /*angle de la rotation*/, glm::vec3{0.f, 0.f, 1.f} /* axe autour duquel on tourne */);\n"})}),"\n",(0,r.jsx)(s.p,{children:"et une matrice de translation avec"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"glm::mat4 const translation = glm::translate(glm::mat4{1.f}, glm::vec3{0.f, 1.f, 0.f} /* d\xe9placement */);    \n"})}),"\n",(0,r.jsxs)(s.p,{children:["(Il faudra include ",(0,r.jsx)(s.code,{children:'#include "glm/ext/matrix_transform.hpp"'}),".)"]}),"\n",(0,r.jsx)(s.p,{children:"Cr\xe9ez une matrice mod\xe8le qui combine une translation et une rotation, et observez le r\xe9sultat. Essayez les deux ordres (rotation suivie de translation, et vice-versa) et vous verrez que ce n'est pas pareil ! L'ordre a son importance !"}),"\n",(0,r.jsx)(s.h2,{id:"cube",children:"Cube"}),"\n",(0,r.jsxs)(s.p,{children:["Maintenant qu'on peut voir en 3D, il est temps de faire notre premier mesh 3D ! Faites le vertex buffer et l'index buffer pour un cube. Je vous laisse ",(0,r.jsx)(s.a,{href:"#index-buffer",children:"revoir le chapitre d\xe9di\xe9 au besoin"}),".",(0,r.jsx)("br",{}),"\nJe vous conseille de faire des petits sch\xe9mas pour ne pas vous y perdre dans les indices, et y aller face par face."]}),"\n",(0,r.jsx)(s.admonition,{title:"Attention",type:"tip",children:(0,r.jsx)(s.p,{children:"Pensez \xe0 modifier aussi votre shader, pour qu'il re\xe7oive une position 3D et plus 2D."})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(5766).A+"",width:"1905",height:"988"})}),"\n",(0,r.jsx)(s.h2,{id:"premier-shader-pour-mieux-voir-la-3d",children:"Premier shader pour mieux voir la 3D"}),"\n",(0,r.jsx)(s.p,{children:"On a du mal \xe0 discerner la 3D sur notre cube monochrome. Nous allons donc changer notre fragment shader pour commencer \xe0 un peu mieux voir tout \xe7a."}),"\n",(0,r.jsx)(s.p,{children:"Une mani\xe8re tr\xe8s simple va \xeatre de passer la position des vertexs du vertex shader vers le fragment shader, puis d'utiliser ces positions comme des couleurs, afin que chaque vertex ait une couleur diff\xe9rente."}),"\n",(0,r.jsxs)(s.p,{children:["Pour cela dans le vertex shader nous allons d\xe9clarer une variable ",(0,r.jsx)(s.code,{children:"out"}),", qui sera transmise au fragment shader automatiquement :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",metastring:'title="res/vertex.glsl"',children:"// \xc0 mettre avant le main\nout vec3 vertex_position;\n"})}),"\n",(0,r.jsx)(s.p,{children:"puis on l'assigne dans le main :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",metastring:'title="res/vertex.glsl"',children:"vertex_position = in_position;\n"})}),"\n",(0,r.jsxs)(s.p,{children:["et ensuite dans le fragment shader on d\xe9clare un variable ",(0,r.jsx)(s.code,{children:"in"})," avec le m\xeame nom et le m\xeame type que la variable ",(0,r.jsx)(s.code,{children:"out"})," de notre vertex shader :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",metastring:'title="res/fragment.glsl"',children:"// \xc0 mettre avant le main\nin vec3 vertex_position;\n"})}),"\n",(0,r.jsx)(s.p,{children:"et on peut l'utiliser dans notre main :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-glsl",metastring:'title="res/fragment.glsl"',children:"out_color = vec4(vertex_position, 1.);\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(8402).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.p,{children:"Si votre cube vous para\xeet un peu bizarre, c'est normal, il nous manque encore un Depth Buffer pour faire de la 3D correctement !"}),"\n",(0,r.jsx)(s.admonition,{title:"Note",type:"tip",children:(0,r.jsxs)(s.p,{children:["Vous avez peut-\xeatre remarqu\xe9 qu'il y a un d\xe9grad\xe9 de couleurs. C'est parce que, quand on passe une variable ",(0,r.jsx)(s.code,{children:"in"})," / ",(0,r.jsx)(s.code,{children:"out"})," entre le vertex shader et le fragment shader, elle est interpol\xe9e pour chaque pixel (en faisant une moyenne de la valeur aux trois sommets du triangle contenant le pixel).\nTODO image"]})}),"\n",(0,r.jsx)(s.h2,{id:"depth-buffer",children:"Depth Buffer"}),"\n",(0,r.jsx)(s.p,{children:"Le probl\xe8me avec notre rendu pour l'instant, c'est que les triangles se dessinent les uns apr\xe8s les autres et se recouvrent. Et si par malchance c'est une face arri\xe8re du cube qui est dessin\xe9e en derni\xe8re, alors elle va venir cacher les faces avant qui ont \xe9t\xe9 dessin\xe9es avant."}),"\n",(0,r.jsx)(s.p,{children:"Pour rem\xe9dier \xe0 \xe7a, il faut activer le Depth Test :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"// \xc0 mettre dans l'initialisation\nglEnable(GL_DEPTH_TEST);\n"})}),"\n",(0,r.jsx)(s.p,{children:"et clear le depth buffer \xe0 chaque frame, tout comme on clear la couleur de l'\xe9cran :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Vient remplacer glClear(GL_COLOR_BUFFER_BIT);\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(9947).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.p,{children:"Et voil\xe0 ! Notre premier rendu 3D qui ressemble \xe0 peu pr\xe8s \xe0 quelque chose ! \ud83c\udf89"}),"\n",(0,r.jsx)(s.p,{children:"Et qu'est-ce donc qu'un Depth Buffer au fait ? C'est une deuxi\xe8me image, qui se cr\xe9e en parall\xe8le de la couleur qu'on met \xe0 l'\xe9cran, et qui stocke la profondeur correspondant \xe0 chaque pixel. Ainsi chaque triangle dessine \xe0 la fois une couleur \xe0 l'\xe9cran (contr\xf4l\xe9e par le fragment shader), et aussi une \"couleur\" dans le depth buffer. Et avant m\xeame de dessiner, on v\xe9rifie pour chaque pixel si il n'y avait pas d\xe9j\xe0 eu quelque chose de dessin\xe9 sur ce pixel, et si oui on compare leur profondeur, et on recolorie le pixel avec la nouvelle couleur seulement si il est plus proche de la cam\xe9ra que l'objet pr\xe9c\xe9demment dessin\xe9 (on obtient cette distance \xe0 la cam\xe9ra justement en allant lire le depth buffer)."}),"\n",(0,r.jsx)(s.p,{children:"On peut aller visualiser notre Depth Buffer dans RenderDoc :"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(6028).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsxs)(s.p,{children:["Dans l'onglet ",(0,r.jsx)(s.code,{children:"Outputs"})," il y a maintenant deux images : l'\xe9cran normal (",(0,r.jsx)(s.code,{children:"Backbuffer Color"}),"), et le Depth Buffer (",(0,r.jsx)(s.code,{children:"Backbuffer Depth-stencil"}),"). (NB : pour y voir quelque chose dans le depth buffer, il faut changer la ",(0,r.jsx)(s.code,{children:"Range"}),", car comme le cube est tr\xe8s proche il appara\xeet tr\xe8s blanc dans le depth buffer)."]}),"\n",(0,r.jsx)(s.admonition,{title:"Remarque",type:"info",children:(0,r.jsxs)(s.p,{children:["On verra un usage cr\xe9atif du depth buffer pour faire un ",(0,r.jsx)(s.a,{href:"TODO",children:"effet de rendu See-Through"}),"."]})}),"\n",(0,r.jsx)(s.h2,{id:"texture",children:"Texture"}),"\n",(0,r.jsx)(s.h3,{id:"uv",children:"UV"}),"\n",(0,r.jsxs)(s.p,{children:["Nous allons maintenant appliquer une texture \xe0 notre objet ! Pour cela, il nous faut tout d'abord des coordonn\xe9es de texture, qui vont indiquer quelle partie de la texture s'applique \xe0 quelle partie du mesh. Pour l'instant revenez \xe0 un mesh de carr\xe9, et rajoutez un vertex attribute de type ",(0,r.jsx)(s.code,{children:"UV"}),". Les coordonn\xe9es de texture sont souvent appel\xe9es UV (U pour l'axe X, et V pour l'axe Y), et vont de 0 \xe0 1.",(0,r.jsx)("br",{}),"\nPour v\xe9rifier que vos UVs sont bien plac\xe9s, vous pouvez les afficher comme une couleur dans le fragment shader: ",(0,r.jsx)(s.code,{children:"out_color = vec4(uv.x, uv.y, 0., 1.);"}),". C'est une technique tr\xe8s souvent utilis\xe9e pour d\xe9buguer sur GPU, comme on n'a pas de ",(0,r.jsx)(s.code,{children:"print()"})," pour afficher des valeurs, on affiche des couleurs et on les interpr\xe8te comme des nombres. Le rouge correspond \xe0 uv.x (0 \xe0 gauche et 1 \xe0 droite), et le vert \xe0 uv.y (0 en bas et 1 en haut). \xc7a doit ressembler \xe0 \xe7a :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(5140).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.h3,{id:"objet-texture",children:"Objet Texture"}),"\n",(0,r.jsx)(s.p,{children:"Une fois qu'on a nos UVs, on peut maintenant cr\xe9er notre objet texture :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"auto const texture = gl::Texture{\n    gl::TextureSource::File{ // Peut \xeatre un fichier, ou directement un tableau de pixels\n        .path           = \"res/texture.png\",\n        .flip_y         = true, // Il n'y a pas de convention universelle sur la direction de l'axe Y. Les fichiers (.png, .jpeg) utilisent souvent une direction diff\xe9rente de celle attendue par OpenGL. Ce bool\xe9en flip_y est l\xe0 pour inverser la texture si jamais elle n'appara\xeet pas dans le bon sens.\n        .texture_format = gl::InternalFormat::RGBA8, // Format dans lequel la texture sera stock\xe9e. On pourrait par exemple utiliser RGBA16 si on voulait 16 bits par canal de couleur au lieu de 8. (Mais \xe7a ne sert \xe0 rien dans notre cas car notre fichier ne contient que 8 bits par canal, donc on ne gagnerait pas de pr\xe9cision). On pourrait aussi stocker en RGB8 si on ne voulait pas de canal alpha. On utilise aussi parfois des textures avec un seul canal (R8) pour des usages sp\xe9cifiques.\n    },\n    gl::TextureOptions{\n        .minification_filter  = gl::Filter::Linear, // Comment on va moyenner les pixels quand on voit l'image de loin ?\n        .magnification_filter = gl::Filter::Linear, // Comment on va interpoler entre les pixels quand on zoom dans l'image ?\n        .wrap_x               = gl::Wrap::Repeat,   // Quelle couleur va-t-on lire si jamais on essaye de lire en dehors de la texture ?\n        .wrap_y               = gl::Wrap::Repeat,   // Idem, mais sur l'axe Y. En g\xe9n\xe9ral on met le m\xeame wrap mode sur les deux axes.\n    }\n};\n"})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.em,{children:(0,r.jsx)(s.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(69).A+"",children:"Si vous voulez, vous pouvez t\xe9l\xe9charger cette texture de test."})})}),"\n",(0,r.jsxs)(s.p,{children:["Nous testerons les diff\xe9rentes ",(0,r.jsx)(s.code,{children:"TextureOptions"})," juste apr\xe8s, mais d\xe9j\xe0 pour afficher la texture il ne vous reste plus qu'\xe0 :"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["D\xe9clarer une variable uniforme de type ",(0,r.jsx)(s.code,{children:"sampler2D"})," dans le fragment shader. (Un sampler est l'objet qui nous permet d'acc\xe9der \xe0 la texture en appliquant les TextureOptions qu'on a choisies) : ",(0,r.jsx)(s.code,{children:"uniform sampler2D my_texture;"})]}),"\n",(0,r.jsxs)(s.li,{children:["Passer la texture au shader via une variable uniforme : ",(0,r.jsx)(s.code,{children:'shader.set_uniform("my_texture", texture);'})]}),"\n",(0,r.jsxs)(s.li,{children:["De nouveau dans le fragment shader, lire la texture \xe0 la position ",(0,r.jsx)(s.code,{children:"uv"})," gr\xe2ce \xe0 la fonction ",(0,r.jsx)(s.code,{children:"texture()"})," de glsl : ",(0,r.jsx)(s.code,{children:"vec4 texture_color = texture(my_texture, uv);"})," et la retourner en sortie du fragment shader."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.em,{children:"Et voil\xe0 !"}),"\n",(0,r.jsx)(s.img,{src:n(8381).A+"",width:"1920",height:"1030"})]}),"\n",(0,r.jsx)(s.h3,{id:"options-de-texture",children:"Options de texture"}),"\n",(0,r.jsx)(s.h4,{id:"wrap",children:"Wrap"}),"\n",(0,r.jsxs)(s.p,{children:["Le mode de wrapping contr\xf4le ce qu'il se passe quand on passe des UVs \xe0 la fonction ",(0,r.jsx)(s.code,{children:"texture()"})," qui ne sont pas entre 0 et 1. Plut\xf4t que de crash comme le ferait un tableau normal quand on utilise un index invalide (< 0 ou >= size), la texture va quand m\xeame retourner une couleur. Pour tester ces diff\xe9rents modes, utilisez des UVs qui vont de -1 \xe0 2, et testez tous les modes ! Vous verrez que les noms sont plut\xf4t explicites. (PS : pour le mode ",(0,r.jsx)(s.code,{children:"ClampToBorder"})," il faut sp\xe9cifier le param\xe8tre ",(0,r.jsx)(s.code,{children:"border_color"})," en plus dans ",(0,r.jsx)(s.code,{children:"TextureOptions"}),")."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.em,{children:"gl::Wrap::MirroredRepeat"}),"\n",(0,r.jsx)(s.img,{src:n(2966).A+"",width:"1920",height:"1030"})]}),"\n",(0,r.jsx)(s.h4,{id:"filter",children:"Filter"}),"\n",(0,r.jsx)(s.p,{children:"Le filtre de magnification contr\xf4le ce qu'il se passe quand on zoome dans l'image. Pour en visualiser l'effet, utilisez des UVs qui vont de 0.8 \xe0 0.9 par exemple."}),"\n",(0,r.jsx)(s.admonition,{title:"Note",type:"info",children:(0,r.jsxs)(s.p,{children:["Pour le filtre ",(0,r.jsx)(s.code,{children:"LinearMipmapLinear"})," il faut avoir cr\xe9\xe9 des mipmaps pour votre texture, nous en parlerons plus tard."]})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.em,{children:"gl::Filter::NearestNeighbour"}),"\n",(0,r.jsx)(s.img,{src:n(6767).A+"",width:"1920",height:"1030"})]}),"\n",(0,r.jsx)(s.p,{children:'Le filtre de magnification est utilis\xe9e quand la texture est vue de loin et couvre "peu" de pixels \xe0 l\'\xe9cran (moins que le nombre de pixels dans la texture).'}),"\n",(0,r.jsxs)(s.p,{children:["L'effet du filtre est beaucoup moins visible, et c'est surtout quand il y a du mouvement que le filtre Linear peut \xe9viter un peu de flicker. Vous pouvez le voir ",(0,r.jsx)(s.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(7897).A+"",children:"en utilisant une texture d'\xe9chiquier"}),", des UVs entre 0 et 30, et en faisant d\xe9placer la texture \xe0 une vitesse de 0.0001 par seconde."]}),"\n",(0,r.jsx)(s.h3,{id:"bonus--textures-proc\xe9durales",children:"Bonus : textures proc\xe9durales"}),"\n",(0,r.jsxs)(s.p,{children:['Il est aussi possible, au lieu de lire une texture, de colorier un triangle en calculant une "texture" proc\xe9durale en fonction des UVs. On en a d\xe9j\xe0 vu un exemple tr\xe8s simple quand on affich\xe9 nos UVs (',(0,r.jsx)(s.code,{children:"out_color = vec4(uv.x, uv.y, 0., 1.);"}),"), mais on peut faire beaucoup plus ! Par exemple toutes les images sur ",(0,r.jsx)(s.a,{href:"TODO",children:"Shadertoy"})," sont faites ainsi, juste en affichant un quad sur tout l'\xe9cran, et en faisant des calculs \xe9labor\xe9s dans le fragment shader."]}),"\n",(0,r.jsx)(s.p,{children:"Pour commencer simplement, vous pouvez vous demander comment produire un disque, ou un pattern d'\xe9chiquier :"}),"\n",(0,r.jsx)(s.table,{children:(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:(0,r.jsx)(s.img,{src:n(6326).A+"",width:"722",height:"759"})}),(0,r.jsx)(s.th,{children:(0,r.jsx)(s.img,{src:n(8093).A+"",width:"720",height:"759"})})]})})}),"\n",(0,r.jsxs)(s.p,{children:["Pour aller plus loin, je vous recommande les excellentes vid\xe9os de ",(0,r.jsx)(s.a,{href:"TODO",children:"The Art of Code"})," (et Inigo ?) TODO mettre une image d'une fin de tuto styl\xe9e"]}),"\n",(0,r.jsx)(s.h3,{id:"cube-textur\xe9",children:"Cube textur\xe9"}),"\n",(0,r.jsx)(s.p,{children:"Vous pouvez maintenant reprendre votre mesh de cube, et lui rajouter des UVs pour pouvoir appliquer une texture. Vous remarquerez qu'on ne peut pas avoir la texture qui s'affiche bien sur les 6 faces \xe0 la fois. Du moins tant qu'on n'utilise que 8 vertexs. En effet, utiliser un index buffer c'est bien pratique, mais parfois on a besoin de dupliquer nos sommets afin d'avoir un attribut diff\xe9rent pour chaque face m\xeame si elles partagent un m\xeame sommet. Par exemple ici nos sommets partagent la m\xeame position, mais pas les m\xeames UVs en fonction de la face qu'on consid\xe8re. Ne vous emb\xeatez pas \xe0 le faire, mais sachez que pour r\xe9soudre ce probl\xe8me dans le cas de notre cube il faudrait se passer d'un index buffer, et re-pr\xe9ciser les sommet une fois pour chaque triangle, comme on le faisait au d\xe9but. (Donc 36 sommets dans le cas de notre cube !)"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(1745).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.h2,{id:"render-target",children:"Render Target"}),"\n",(0,r.jsxs)(s.p,{children:["Pour finir ce long chapitre sur les diff\xe9rents objets fondamentaux des moteurs de rendu 3D, nous allons parler des Render Targets ! (Aussi appel\xe9es ",(0,r.jsx)(s.strong,{children:"Framebuffers"}),")."]}),"\n",(0,r.jsx)(s.p,{children:"Une Render Target sert \xe0 faire notre rendu sur une texture \xe0 part, au lieu de le faire directement \xe0 l'\xe9cran. \xc7a peut \xeatre tr\xe8s utile quand on a besoin de r\xe9utiliser l'image produite, par exemple pour appliquer du post-processing dessus."}),"\n",(0,r.jsxs)(s.p,{children:["Commencez par cr\xe9er une Render Target : vous reconna\xeetrez certains param\xe8tres qu'on a d\xe9j\xe0 utilis\xe9s en ",(0,r.jsx)(s.a,{href:"#objet-texture",children:"cr\xe9ant une texture"})," :"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"auto render_target = gl::RenderTarget{gl::RenderTarget_Descriptor{\n    .width          = gl::framebuffer_width_in_pixels(),\n    .height         = gl::framebuffer_height_in_pixels(),\n    .color_textures = {\n        gl::ColorAttachment_Descriptor{\n            .format  = gl::InternalFormat_Color::RGBA8,\n            .options = {\n                .minification_filter  = gl::Filter::NearestNeighbour, // On va toujours afficher la texture \xe0 la taille de l'\xe9cran,\n                .magnification_filter = gl::Filter::NearestNeighbour, // donc les filtres n'auront pas d'effet. Tant qu'\xe0 faire on choisit le moins co\xfbteux.\n                .wrap_x               = gl::Wrap::ClampToEdge,\n                .wrap_y               = gl::Wrap::ClampToEdge,\n            },\n        },\n    },\n    .depth_stencil_texture = gl::DepthStencilAttachment_Descriptor{\n        .format  = gl::InternalFormat_DepthStencil::Depth32F,\n        .options = {\n            .minification_filter  = gl::Filter::NearestNeighbour,\n            .magnification_filter = gl::Filter::NearestNeighbour,\n            .wrap_x               = gl::Wrap::ClampToEdge,\n            .wrap_y               = gl::Wrap::ClampToEdge,\n        },\n    },\n}};\n"})}),"\n",(0,r.jsxs)(s.p,{children:["En g\xe9n\xe9ral une Render Target a plusieurs textures (qu'on appelle des ",(0,r.jsx)(s.em,{children:"attachments"}),") : au moins une texture de couleur",(0,r.jsx)(s.sup,{children:(0,r.jsx)(s.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),", et (optionnellement) une texture de profondeur (le fameux ",(0,r.jsx)(s.a,{href:"#depth-buffer",children:"Depth Buffer"}),") (qui peut aussi contenir un ",(0,r.jsx)(s.a,{href:"TODO",children:"Stencil Buffer"})," dont nous reparlerons plus tard)."]}),"\n",(0,r.jsx)(s.p,{children:"Puisque dans notre cas on va utiliser la render target pour faire du post-processing, on veut que la texture aie la m\xeame taille que l'\xe9cran. C'est pourquoi on l'initialise avec"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:".width  = gl::framebuffer_width_in_pixels(),\n.height = gl::framebuffer_height_in_pixels(),\n"})}),"\n",(0,r.jsx)(s.p,{children:"mais il faut \xe9galement la changer si la fen\xeatre est redimensionn\xe9e ! Rajoutez cet event callback :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"gl::set_events_callbacks({\n    camera.events_callbacks(),\n    {.on_framebuffer_resized = [&](gl::FramebufferResizedEvent const& e) {\n        render_target.resize(e.width_in_pixels, e.height_in_pixels);\n    }},\n});\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Maintenant que notre render target est cr\xe9\xe9e, on peut dessiner dessus. Pour cela, il suffit d'appeler sa m\xe9thode ",(0,r.jsx)(s.code,{children:"render()"})," et de lui passer un callback contenant du code de dessin normal. Ces draw calls dessineront non pas \xe0 l'\xe9cran, mais sur notre render target !"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:" render_target.render([&]() {\n    glClearColor(1.f, 0.f, 0.f, 1.f); // Dessine du rouge, non pas \xe0 l'\xe9cran, mais sur notre render target\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    // ... mettez tout votre code de rendu ici\n});\n"})}),"\n",(0,r.jsxs)(s.p,{children:["En faisant \xe7a on ne voit plus rien \xe0 l'\xe9cran, et c'est normal car tout est maintenant mis sur notre render target \xe0 la place. Nous allons l'afficher dans un instant, mais en attendant on peut d\xe9j\xe0 aller la voir dans RenderDoc et confirmer que le rendu s'est bien fait :\n",(0,r.jsx)(s.img,{src:n(1941).A+"",width:"1920",height:"1030"})]}),"\n",(0,r.jsxs)(s.p,{children:["Notre cube est toujours l\xe0, mais au lieu d'\xeatre rendu \xe0 l'\xe9cran (qui s'appelait ",(0,r.jsx)(s.code,{children:"Backbuffer Color"})," dans notre capture RenderDoc), la texture d'output est maintenant ",(0,r.jsx)(s.code,{children:"Texture 54"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["Maintenant pour afficher notre texture, il nous suffit de dessiner un quad sur tout l'\xe9cran, de passer la texture \xe0 un shader, et de la lire ",(0,r.jsx)(s.a,{href:"#objet-texture",children:"comme au chapitre sur les textures"})," :"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(6773).A+"",width:"1920",height:"1030"})}),"\n",(0,r.jsx)(s.p,{children:"Et voil\xe0 ! On est revenu au point de d\xe9part avec notre cube, mais l'avantage c'est qu'on peut maintenant manipuler la texture comme on veut dans un shader et appliquer plein d'effets !"}),"\n",(0,r.jsx)(s.h3,{id:"post-process",children:"Post-Process"}),"\n",(0,r.jsx)(s.p,{children:"Dans le fragment shader qui lit la texture de la render target, on peut maintenant manipuler la couleur comme on veut ! Essayez de tout passer en noir et blanc, ou de ne garder que la composante rouge de l'image :"}),"\n",(0,r.jsx)(s.table,{children:(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:(0,r.jsx)(s.img,{src:n(1666).A+"",width:"802",height:"839"})}),(0,r.jsx)(s.th,{children:(0,r.jsx)(s.img,{src:n(5673).A+"",width:"803",height:"839"})})]})})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Bonus :"})," Vous pouvez aussi tenter plein d'autres effets, comme augmenter le contraste ou la saturation de l'image, faire du vignettage, d\xe9former l'image, etc."]}),"\n",(0,r.jsx)(s.h3,{id:"bonus--fade",children:"Bonus : Fade"}),"\n",(0,r.jsxs)(s.p,{children:["Utiliser une render target peut aussi permettre de choisir le format (e.g. ",(0,r.jsx)(s.code,{children:"RGBA8"}),") de la texture sur laquelle on rend, au lieu d'\xeatre limit\xe9 \xe0 la valeur choisie par d\xe9faut par OpenGL. Reprenez votre code du ",(0,r.jsx)(s.a,{href:"#bonus--effet-de-fade",children:"fade"}),", et faites maintenant le rendu sur une render target utilisant un format avec 16 ou 32 bits par canal au lieu de 8, \xe7a va r\xe9gler les probl\xe8mes de pr\xe9cision qu'on avait. Et le fait d'utiliser une render target r\xe8gle aussi le probl\xe8me de swapchain qui faisait clignoter l'image."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(8180).A+"",width:"1272",height:"714"})}),"\n",(0,r.jsx)(s.h3,{id:"autres-utilisations",children:"Autres utilisations"}),"\n",(0,r.jsxs)(s.admonition,{title:"Note",type:"tip",children:[(0,r.jsx)(s.p,{children:"Sur ce sch\xe9ma du pipeline de rendu d'Unreal, la plupart des \xe9tapes interm\xe9diaires stockent leur r\xe9sultat dans une render target, qui sont ensuite r\xe9utilis\xe9es par d'autres \xe9tapes. \xc7a vous donne une id\xe9e du nombre de render targets utilis\xe9es !"}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:n(9194).A+"",width:"10240",height:"5753"})})]}),"\n",(0,r.jsxs)(s.section,{"data-footnotes":!0,className:"footnotes",children:[(0,r.jsx)(s.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{id:"user-content-fn-1",children:["\n",(0,r.jsxs)(s.p,{children:["Il peut y en avoir plusieurs. \xc7a permet de dessiner sur plusieurs textures en m\xeame temps avec un seul draw call. Pour cela il suffit dans le fragment shader de d\xe9clarer plusieurs variables ",(0,r.jsx)(s.code,{children:"out"}),": ",(0,r.jsx)(s.code,{children:"out vec4 out_color1; out vec4 out_color2;"})," et d'\xe9crire dans chacune d'elles. ",(0,r.jsx)(s.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function A(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},7897:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/files/checkerboard-df9940b6f4e556d0cf57199e78165efd.jpg"},69:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/files/texture-2b39c87c6a92ef42086e1627d4339ade.png"},9194:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/Unreal-Render-Pipeline-fe7c893b6eade96300a70fb660a59d3b.png"},7606:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/distance_tronc-453da9c5dba4d7f7406bf9f763cb7520.png"},9301:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/mesh-6d2a9d063c52d08731e62a56997d63ab.png"},80:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-01-e445b887989532c81f26f491e9773263.png"},8411:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-02-55fe7dec86cb399229cef2fee5e1c533.png"},3586:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-03-ddcd98d0f4b3eb3e782450ac08c50540.png"},8445:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-04-a9199795ebe29acaed9cf942eb8edbb5.png"},4548:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-05-eb2cb960641c81751011019664418bf6.png"},1407:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-06-8eb7946002c4dcd9aa15e0030234dfc9.png"},4470:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-07-25c6dadd5f6a40cf8eefba1546db0031.png"},1777:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-08-27424ba7949f835d127aab6b8dce94d8.png"},1560:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-09-0c2ed4bc27d6f257fdac2dbb7db84450.png"},4110:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-10-6f2bbbb7cc326a403dd6c363d6c7e4ff.png"},3607:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-11-6bc65faf7f71db7d1268480e3defd1c1.png"},6028:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-12-2ee73a6b9a09de7be8a61c3177acd031.png"},1941:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/renderdoc-13-0f034ce53d0127089cee701a1f046570.png"},6635:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-00-c5ddc38ab1238e794fb8cc09e8a82681.png"},5506:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-01-136504958c3bdfddaee41c47910ec272.png"},1593:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-02-b55694e2af3ed818b7ecd2bbb62f8a85.png"},1215:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-04-32d16a71c191fdd4e69ad9df4d41ad14.png"},2198:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-05-aec1a47c27f10ec482a85e3f1da45c30.png"},9757:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-06-be66a8febb2dd65bff9034023f9e93ea.png"},6724:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-07-09faf623d94c1e38c689b37b81031ee2.png"},2965:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-08-00-c0e65cb9588307a51111ea48152fff7e.gif"},8380:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-08-01-28f906bc6dad429bc9985f1a3bd99be0.gif"},6147:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-08-02-bc286bb8463c7ba6d7f6d9c304dbc3c0.gif"},1161:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-09-abf36406361a4032fa7ce1cf1112af2a.gif"},527:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-10-576c30bd1bbf225712645226564db5c3.gif"},5766:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-11-ec5eda602e0a1521dd6a508c38e645c6.gif"},8402:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-12-5bea704238522e94a6b49e1c6c7c3e55.png"},9947:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-13-a049282c6f0e6f108285b78d53b36a0e.png"},5140:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-14-b23db5d9449bfaf4f911ec9bccb10dd1.png"},8381:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-15-75fba339714d10fdb56a2c5347acd8a4.png"},2966:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-16-931e865cfa9b2fbfffc0bf7d76d5dbc0.png"},6767:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-17-04cadf4dce66909abd3938a31350a043.png"},6326:(e,s,n)=>{n.d(s,{A:()=>r});const r="data:image/png;base64,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"},8093:(e,s,n)=>{n.d(s,{A:()=>r});const r="data:image/png;base64,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AEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAQEADAEBAQAMAQEBAAwBAoOr1evXCwkJ7yDhVVdXuMU51Xbd7jJPxPBnG82QYz5NhPE+G8TxeMzMzZqABACAhoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAICCgAQAgIKABACAgoAEAINCZnp5udwEAgDvpXLt2rd0FAADuxBIOAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAICGgAAAgIaAAACAhoAAAIVL1er15cXGwPGae6rts9xqmqqnaPcTKeJ8N4ngzjeTKM58kwnser3++bgQYAgISABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAgIAGAICAgAYAgICABgCAEU1NTQloAAAY1bVr1wQ0AAAkBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAASqXq9XLywstIeMU1VV7R7jVNd1u8c4Gc+TYTxPhvE8GcbzZBjP4zVoZzPQAACQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAwouXlZQENAACjqqpKQAMAwKgENAAABAQ0AACEBDQAAIzIDDQAAIQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAABAQ0AAAEBDQAAAQENAAAjKyU/wMLfO4Ssbt07gAAAABJRU5ErkJggg=="},1745:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-19-617a99e9d59f487b1b0970c377367a57.png"},6773:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-20-4322c740d97755f87a57fb2029eec517.png"},1666:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-21-1-5fbf2aefb68984df46bf5e1c52350147.png"},5673:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-21-2-e7c436c8cf0b78bc91fca96aa6bf155f.png"},8180:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/step-22-e7fc2f93ed88424c57335338c8537896.gif"},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>l});var r=n(6540);const t={},i=r.createContext(t);function a(e){const s=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);