"use strict";(self.webpackChunkrendering=self.webpackChunkrendering||[]).push([[681],{6078:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>a});var r=n(4848),l=n(8453);const t={},i=void 0,o={id:"Shaders Unreal/Cours 1 - Partie 1",title:"Cours 1 - Partie 1",description:"Rappels",source:"@site/docs/Shaders Unreal/01-Cours 1 - Partie 1.md",sourceDirName:"Shaders Unreal",slug:"/Shaders Unreal/Cours 1 - Partie 1",permalink:"/Rendering/Shaders Unreal/Cours 1 - Partie 1",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"ShadersUnreal",next:{title:"Exos 1 - Partie 1",permalink:"/Rendering/Shaders Unreal/Exos 1 - Partie 1"}},d={},a=[{value:"Rappels",id:"rappels",level:2},{value:"Fonctions utiles",id:"fonctions-utiles",level:2}];function c(e){const s={code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h2,{id:"rappels",children:"Rappels"}),"\n",(0,r.jsxs)(s.p,{children:["Un shader est un programme qui s'ex\xe9cute sur le ",(0,r.jsx)(s.strong,{children:"GPU"})," (contrairement aux programmes dont vous avez l'habitude, qui tournent sur le ",(0,r.jsx)(s.strong,{children:"CPU"}),")."]}),"\n",(0,r.jsx)(s.p,{children:"La force du GPU est d'\xeatre tr\xe8s parall\xe9lis\xe9 : l\xe0 o\xf9 un CPU aura quelques dizaines de threads, un GPU en a des milliers ! Il peut donc faire \xe9norm\xe9ment d'op\xe9rations en parall\xe8le, par exemple traiter des milliers de pixels en m\xeame temps, ou des milliers de sommets d'un mesh."}),"\n",(0,r.jsx)(s.p,{children:"Il existe diff\xe9rents types de shaders :"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["le ",(0,r.jsx)(s.strong,{children:"vertex shader"})," process des sommets : il re\xe7oit toutes les infos d'un sommet (position, normale, etc.) et les modifie (par exemple positionne le mod\xe8le au bon endroit dans le monde, applique la cam\xe9ra, etc.)"]}),"\n",(0,r.jsxs)(s.li,{children:["le ",(0,r.jsx)(s.strong,{children:"fragment shader"})," process des pixels : il re\xe7oit des infos du vertex shader (qui s'ex\xe9cute avant), et doit retourner une couleur pour le pixel en question, et appliquant l'\xe9clairage, nos effets custom, etc."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Dans le Material Editor de Unreal ces deux shaders sont pr\xe9sent\xe9s dans un seul graphe, mais il est bon de toujours se rappeler que ce sont deux \xe9tapes s\xe9par\xe9es : d'abord le vertex, puis le fragment."}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["le ",(0,r.jsx)(s.strong,{children:"compute shader"})," est en dehors de la pipeline classique du rendu 3D. C'est un shader plus r\xe9cent, et plus g\xe9n\xe9rique. Il prend des tableaux quelconques, et les modifie comme il veut. C'est de plus en plus utilis\xe9s pour acc\xe9l\xe9rer certains syst\xe8mes, par exemple les simulations de cloth, ou les particules."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["Il existe aussi d'autre types beaucoup plus niches, comme le ",(0,r.jsx)(s.strong,{children:"geometry shader"})," et le ",(0,r.jsx)(s.strong,{children:"tesselation shader"}),", dont nous ne parlerons pas."]}),"\n",(0,r.jsx)(s.h2,{id:"fonctions-utiles",children:"Fonctions utiles"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"Add"}),": translation"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"Multiply"}),": scale"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"Step"})," / ",(0,r.jsx)(s.code,{children:"SmoothStep"}),": seuils"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"Frac"})," / ",(0,r.jsx)(s.code,{children:"Fmod"}),": r\xe9p\xe9titions"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"Sine"})," (sinus): oscillations"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"Lerp"})," / ",(0,r.jsx)(s.code,{children:"InvLerp"})," / ",(0,r.jsx)(s.code,{children:"RemapValueRange"}),": remapper des valeurs"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,l.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>o});var r=n(6540);const l={},t=r.createContext(l);function i(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);