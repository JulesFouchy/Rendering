{"searchDocs":[{"title":"Pipeline de Rendu","type":0,"sectionRef":"#","url":"/Rendering/Deep dive","content":"Pipeline de Rendu Voici une vue d'ensemble de tout ce qui se passe dans Unreal : Pour faire plus simple, voici ce qu'il faut retenir sur les bases du rendu 3D en rasterisation : Que vous pouvez retrouver expliqu√©es dans cette super vid√©o :","keywords":"","version":"Next"},{"title":"Anti-Aliasing","type":0,"sectionRef":"#","url":"/Rendering/Deep dive/Anti-Aliasing","content":"","keywords":"","version":"Next"},{"title":"Qu'est-ce que l'aliasing ?‚Äã","type":1,"pageTitle":"Anti-Aliasing","url":"/Rendering/Deep dive/Anti-Aliasing#quest-ce-que-laliasing-","content":" Quand vous essayez de dessiner une ligne en diagonale, elle ne peut pas aller &quot;tout droit&quot;, elle est oblig√©e de suivre la grille de pixels, c'est &quot;l'effet escalier&quot; :    Ce qui, vu de loin, donne un aspect rugueux :    L'anti-aliasing consiste √† &quot;flouter&quot; l'objet pour que, vu de loin, il apparaisse plus lisse :    ","version":"Next","tagName":"h2"},{"title":"Les diff√©rentes techniques d'anti-aliasing‚Äã","type":1,"pageTitle":"Anti-Aliasing","url":"/Rendering/Deep dive/Anti-Aliasing#les-diff√©rentes-techniques-danti-aliasing","content":"     ","version":"Next","tagName":"h2"},{"title":"SSAA (Super-Sampling Anti-Aliasing)‚Äã","type":1,"pageTitle":"Anti-Aliasing","url":"/Rendering/Deep dive/Anti-Aliasing#ssaa-super-sampling-anti-aliasing","content":" ‚ûï Excellente qualit√© quand on monte le nombre de samples (e.g. 64) ‚ûñ Tr√®s co√ªteux en performance ‚ûñ Tr√®s mauvais ratio qualit√© / performance  La plus vieille technique d'anti-aliasing, elle est tr√®s simple : elle revient √† dessiner sur une image N fois plus grande (N = nombre de samples), puis √† la downscale √† la taille d√©sir√©e. Ca marche tr√®s bien, mais √ßa prend beaucoup de temps.  ","version":"Next","tagName":"h3"},{"title":"MSAA (Multi-Sampling Anti-Aliasing) et‚Äã","type":1,"pageTitle":"Anti-Aliasing","url":"/Rendering/Deep dive/Anti-Aliasing#msaa-multi-sampling-anti-aliasing-et","content":" Similaire √† SSAA, en un peu moins quali et un peu meilleur en performance, mais reste tr√®s co√ªteux et a un mauvais ratio qualit√© / performance.  ","version":"Next","tagName":"h3"},{"title":"FXAA (Fast Approximate Anti-Aliasing)‚Äã","type":1,"pageTitle":"Anti-Aliasing","url":"/Rendering/Deep dive/Anti-Aliasing#fxaa-fast-approximate-anti-aliasing","content":" Une technique de post-processing, qui d√©tecte les contours des objets et les floute. Relativement efficace et quali, mais a √©t√© remplac√©e par SMAA, qui fait la m√™me chose en mieux.  ","version":"Next","tagName":"h3"},{"title":"SMAA (Subpixel Morphological Anti-Aliasing)‚Äã","type":1,"pageTitle":"Anti-Aliasing","url":"/Rendering/Deep dive/Anti-Aliasing#smaa-subpixel-morphological-anti-aliasing","content":" Technique r√©cente, tr√®s quali, comme FXAA en plus quali, mais un peu plus co√ªteux.  ","version":"Next","tagName":"h3"},{"title":"TXAA (Temporal Anti-Aliasing)‚Äã","type":1,"pageTitle":"Anti-Aliasing","url":"/Rendering/Deep dive/Anti-Aliasing#txaa-temporal-anti-aliasing","content":" Anti-aliasing pour les objets qui bougent.  ","version":"Next","tagName":"h3"},{"title":"TAA (Temporal Anti-Aliasing)‚Äã","type":1,"pageTitle":"Anti-Aliasing","url":"/Rendering/Deep dive/Anti-Aliasing#taa-temporal-anti-aliasing","content":" √Ä ne pas confondre avec TXAA! Les deux techniques n'ont rien √† voir. TXAA g√®re les objets en mouvement, l√† o√π TAA r√©utilise les frames pr√©c√©dentes pour am√©liorer l'anti-aliasing.  R√©utilise les informations des frames pr√©c√©dentes pour faire du &quot;multisampling&quot;. Elle est donc quasiment aussi quali que SSAA, mais sans l'√©norme co√ªt en performance. Technique tr√®s quali, tr√®s bon rapport qualit√© / performance, et sur laquelle de nombreux autre effets se basent. Elle a une place importante dans le pipe de rendu de tous les moteurs modernes. Rarement expos√© dans les settings graphiques, car on ne peut pas le d√©sactiver, puisque plein d'autres effets en d√©pendent. ","version":"Next","tagName":"h3"},{"title":"LOD - Level of Detail","type":0,"sectionRef":"#","url":"/Rendering/Deep dive/LOD - Level of Detail","content":"LOD - Level of Detail","keywords":"","version":"Next"},{"title":"Graphics Settings","type":0,"sectionRef":"#","url":"/Rendering/Deep dive/Graphics Settings","content":"","keywords":"","version":"Next"},{"title":"Activit√©‚Äã","type":1,"pageTitle":"Graphics Settings","url":"/Rendering/Deep dive/Graphics Settings#activit√©","content":" Allez dans votre jeu vid√©o pr√©f√©r√©, ou dans Unreal, ou Blender (utilisez EEVEE comme moteur de rendu, car c'est un moteur en rasterization, donc plus proche des moteurs de rendu de jeu vid√©o).  ","version":"Next","tagName":"h2"},{"title":"Explications‚Äã","type":1,"pageTitle":"Graphics Settings","url":"/Rendering/Deep dive/Graphics Settings#explications","content":" Je recommande ces deux vid√©os :     ","version":"Next","tagName":"h2"},{"title":"Normal maps","type":0,"sectionRef":"#","url":"/Rendering/Deep dive/Normal maps","content":"","keywords":"","version":"Next"},{"title":"Qu'est-ce qu'une normal map ?‚Äã","type":1,"pageTitle":"Normal maps","url":"/Rendering/Deep dive/Normal maps#quest-ce-quune-normal-map-","content":" Une normal map permet de rajouter des d√©tails et une impression de relief sur un mesh avec relativement peu de triangles. Cela permet d'√©conomiser beaucoup de performances, et est donc indispensable pour les assets d'un jeu vid√©o !  Les normales d'un mod√®le sont les informations qui indiquent dans quelle direction la surface est orient√©e, et elles permettent de calculer les effets de lumi√®re. Ce sont les fl√®ches grises sur ce sch√©ma :  Par d√©faut, elles sont calcul√©es en fonction des triangles, et donc plus il y a de triangles plus les normales sont vari√©es et rajoutent du relief. Mais il est possible de sauvegarder ces normales dans une texture, afin que chaque pixel du triangle ait une normale diff√©rente. On peut ainsi garder les informations des normales, m√™me en ayant moins de triangles.  La seule chose qu'on perd avec une normal map, c'est le volume r√©el : en mettant votre vue rasante avec l'objet, vous verrez qu'il est plat et l'illusion est cass√©e.  ","version":"Next","tagName":"h2"},{"title":"TP : cr√©er une normal map‚Äã","type":1,"pageTitle":"Normal maps","url":"/Rendering/Deep dive/Normal maps#tp--cr√©er-une-normal-map","content":" Pour ce TP nous allons utiliser Blender. Si vous ne l'avez pas d√©j√†, vous pouvez le t√©l√©charger ici. NB : j'utilise la version 4.1 de Blender (la derni√®re en date), mais vous devriez pouvoir suivre avec n'importe quelle version de Blender.T√©l√©chargez le mod√®le qui nous servira d'exemple et importez-le dans Blender. (Si vous avez Blender 4.1, il vous suffit de drag'n drop le fichier. Et sinon, allez dans le menu File &gt; Import &gt; Wavefront (.obj))En affichant le wireframe du mesh, vous verrez qu'il contient √âNORM√âMENT de triangles. C'est tr√®s bien pour du cin√©ma o√π on veut la qualit√© maximale, mais pour du jeu vid√©o le co√ªt en performance sera beaucoup trop √©lev√©, pour un gain de qualit√© pas si important. On a moyen de beaucoup all√©ger le mesh, tout en gardant une grosse partie des d√©tails, gr√¢ce √† une normal map.Vous pouvez afficher le nombre de triangles en activant les statistiquesPour cr√©er une normal map, suivez le tuto ci-dessous. Lors du decimate (r√©duction du nombre de triangles), vous pouvez mettre le ratio √† 0.001 (Vous pouvez aussi exp√©rimenter avec d'autres ratios, et voir jusqu'o√π vous pouvez aller tout en pr√©servant la qualit√© du rendu. Vous pouvez m√™me cr√©er un simple cylindre, le rendu sera pas mal du tout !)   ","version":"Next","tagName":"h2"},{"title":"Tesselation","type":0,"sectionRef":"#","url":"/Rendering/Deep dive/Tesselation","content":"Tesselation Rajoute de la g√©om√©trie automatiquement sur les meshs proches, pour qu'ils aient d'avantage de d√©tails. Permet essentiellement d'ensuite appliquer une displacement map. https://youtu.be/1UcBwsQTwwI?t=348","keywords":"","version":"Next"},{"title":"VSync","type":0,"sectionRef":"#","url":"/Rendering/Deep dive/VSync","content":"VSync Evite le tearing, en limitant le framerate. Risque : si le jeu tourne √† un poil moins de 60fps, genre 59fps, alors il va automatiquement devoir se limiter √† 30fps pour rester sync avec l'√©cran. GSync : tech dans certains √©crans, qui les fait se refresh d√®s qu'ils recoivent une nouvelle image de la carte graphique. Comme √ßa c'est l'√©cran qui s'adapte √† la CG et plus l'inverse, donc on peut rendre les frames aussi vite qu'on veut / peut. https://youtu.be/1UcBwsQTwwI?t=249","keywords":"","version":"Next"},{"title":"Shadow maps & Ambient Occlusion","type":0,"sectionRef":"#","url":"/Rendering/Deep dive/Shadow maps & Ambient Occlusion","content":"","keywords":"","version":"Next"},{"title":"Shadow Map‚Äã","type":1,"pageTitle":"Shadow maps & Ambient Occlusion","url":"/Rendering/Deep dive/Shadow maps & Ambient Occlusion#shadow-map","content":" ","version":"Next","tagName":"h2"},{"title":"Qu'est-ce qu'une shadow map ?‚Äã","type":1,"pageTitle":"Shadow maps & Ambient Occlusion","url":"/Rendering/Deep dive/Shadow maps & Ambient Occlusion#quest-ce-quune-shadow-map-","content":" L'id√©e est de prendre un screenshot depuis le point de vue de la cam√©ra, pour savoir ce qu'elle peut et ne peut pas &quot;voir&quot;, et donc en d√©duire ce qui est dans la lumi√®re ou dans l'ombre.  AvecSans  Pour tester les shadow maps et l'occlusion ambiante, vous pouvez aller sur ce site, t√©l√©charger IMACUBES-Windows.zip, le d√©zipper, et lancer IMACUBES.exe.    Et vous pouvez activer / d√©sactiver les ombres et changer leurs param√®tres :  ","version":"Next","tagName":"h3"},{"title":"Limites‚Äã","type":1,"pageTitle":"Shadow maps & Ambient Occlusion","url":"/Rendering/Deep dive/Shadow maps & Ambient Occlusion#limites","content":" Sur cette vid√©o on voit une des limitations : seuls les objets proches ont des ombres, et elles apparaissent subitement quand on se rapproche des objets.  ","version":"Next","tagName":"h3"},{"title":"Ambient Occlusion‚Äã","type":1,"pageTitle":"Shadow maps & Ambient Occlusion","url":"/Rendering/Deep dive/Shadow maps & Ambient Occlusion#ambient-occlusion","content":" Les shadow maps √† elles seules ne suffisent pas √† capturer toutes les ombres possibles de mani√®re photor√©aliste. C'est pourquoi d'autres techniques viennent les compl√©menter. L'ambient occlusion s'occupe d'obscurcir les petits recoins.  AvecSans ","version":"Next","tagName":"h2"},{"title":"Intro","type":0,"sectionRef":"#","url":"/Rendering/M1 GP/Intro","content":"Intro Dans ce cours nous allons √©crire notre petit moteur de rendu from scratch, en C++ et en utilisant l'API OpenGL. Le but est que vous d√©couvriez les diff√©rents concepts qui sont au c≈ìur d'un moteur de rendu 3D, et que vous compreniez mieux ce qu'il se passe derri√®re vos outils pr√©f√©r√©s (Unreal, Unity, Blender, etc.). Nous allons parler de : MeshVertex BufferIndex BufferVertex ShaderFragment ShaderVariables uniformesCam√©raMatrice de vueMatrice de projectionMatrice mod√®leDepth BufferTexturesMod√®les d'√©clairage (Blinn‚ÄìPhong, PBR)Post-processingRender TargetOmbres (Shadow Maps) √Ä chaque s√©ance je ferai un petit point de cours (30 min max) pour vous expliquer un concept en d√©tail, puis vous serez en autonomie pour avancer sur les TPs. N'h√©sitez surtout pas √† me poser plein de questions, et √† m'appeler d√®s que vous √™tes bloqu√©.es plus de 5-10 minutes sur quelque chose. Vous serez √©valu√©.es sur ces TPs qu'il faudra me rendre. Il y aura deux notes, une au milieu du trimestre et une √† la fin. Il est donc important d'avancer r√©guli√®rement, car vous serez √©valu√©.es au milieu du trimestre sur l√† o√π vous en √™tes. Il y a quelques sections qui sont marqu√©es Bonus dans les TPs, vous n'√™tes pas oblig√©.es de les faire, mais si vous en avez le temps et l'envie n'h√©sitez pas, √ßa sera valoris√© dans la notation. NB : Votre implication et votre participation en classe influencerons aussi (l√©g√®rement) votre note. IMPORTANT Vous devriez avoir le temps de faire les TPs avec le temps qu'on a en classe, ne vous sentez pas oblig√©.es d'avancer √† la maison. (Et si les TPs s'av√®rent √™tre trop longs pour tout le monde, faites-le moi savoir et j'adapterai mes exigences, pas de panique). Le rendu de vos TPs se fera via GitHub / GitLab, en me mettant un lien sur ce Google Sheet. Faites bien des commits √† chaque √©tape des TPs (en gros √† chaque screenshot dans le TP) ! J'irai les regarder pour voir les choses qui se font effacer au cours du temps (comme le premier triangle que vous allez dessiner par exemple). N'h√©sitez pas √† me faire des retours sur tout probl√®me qu'il pourrait y avoir ! Ce qui m'importe c'est que ce cours soit int√©ressant et enrichissant pour vous, donc je peux le faire √©voluer et le changer si il ne vous convient pas !","keywords":"","version":"Next"},{"title":"Intro","type":0,"sectionRef":"#","url":"/Rendering/M2 GP/Intro","content":"Intro","keywords":"","version":"Next"},{"title":"Ressources","type":0,"sectionRef":"#","url":"/Rendering/Ressources","content":"Ressources Acerola : super cha√Æne Youtube qui vulgarise des concepts / techniques de rendu, et d√©cortique le rendu de certains jeux vid√©os Vid√©o : Les √©l√©ments de base du rendu 3D vulgaris√©s Vid√©os : Cours avanc√© : Explication d√©taill√©e du pipeline de rendu et de plusieurs techniques de rendu Vid√©os : Cours avanc√© : Comment √©crire son propre moteur de rendu en C++ et OpenGL","keywords":"","version":"Next"},{"title":"Partie 3 - Du vrai rendu 3D","type":0,"sectionRef":"#","url":"/Rendering/M1 GP/Partie 3 - Du vrai rendu 3D","content":"","keywords":"","version":"Next"},{"title":"Loader un mesh depuis un fichier‚Äã","type":1,"pageTitle":"Partie 3 - Du vrai rendu 3D","url":"/Rendering/M1 GP/Partie 3 - Du vrai rendu 3D#loader-un-mesh-depuis-un-fichier","content":" ","version":"Next","tagName":"h2"},{"title":"Premier mod√®le d'√©clairage et Normales‚Äã","type":1,"pageTitle":"Partie 3 - Du vrai rendu 3D","url":"/Rendering/M1 GP/Partie 3 - Du vrai rendu 3D#premier-mod√®le-d√©clairage-et-normales","content":" ","version":"Next","tagName":"h2"},{"title":"Post-processing et Render Target (Framebuffer)‚Äã","type":1,"pageTitle":"Partie 3 - Du vrai rendu 3D","url":"/Rendering/M1 GP/Partie 3 - Du vrai rendu 3D#post-processing-et-render-target-framebuffer","content":" ","version":"Next","tagName":"h2"},{"title":"Ombres‚Äã","type":1,"pageTitle":"Partie 3 - Du vrai rendu 3D","url":"/Rendering/M1 GP/Partie 3 - Du vrai rendu 3D#ombres","content":" ","version":"Next","tagName":"h2"},{"title":"Effet see-through‚Äã","type":1,"pageTitle":"Partie 3 - Du vrai rendu 3D","url":"/Rendering/M1 GP/Partie 3 - Du vrai rendu 3D#effet-see-through","content":" -&gt; depth buffer ","version":"Next","tagName":"h2"},{"title":"Partie 1 - Setup","type":0,"sectionRef":"#","url":"/Rendering/M1 GP/Partie 1 - Setup","content":"","keywords":"","version":"Next"},{"title":"Installer Git‚Äã","type":1,"pageTitle":"Partie 1 - Setup","url":"/Rendering/M1 GP/Partie 1 - Setup#installer-git","content":" T√©l√©chargez 64-bit Git for Windows Setup depuis cette page. Vous pouvez laisser toutes les options par d√©faut et installer.  Git est un outil de versioning qui vous permettra de sauvegarder votre code r√©guli√®rement, et de me le partager.  ","version":"Next","tagName":"h2"},{"title":"Installer un compilateur C++‚Äã","type":1,"pageTitle":"Partie 1 - Setup","url":"/Rendering/M1 GP/Partie 1 - Setup#installer-un-compilateur-c","content":" T√©l√©chargez Build Tools for Visual Studio 2022 depuis cette page, lancez l'exe, puis cochez Desktop development with C++ et installez.    Un compilateur va transformer votre code en un programme ex√©cutable. Vous ne l'utiliserez pas directement, mais il est n√©cessaire pour que tout build correctement.  ","version":"Next","tagName":"h2"},{"title":"Installer CMake‚Äã","type":1,"pageTitle":"Partie 1 - Setup","url":"/Rendering/M1 GP/Partie 1 - Setup#installer-cmake","content":" T√©l√©chargez Windows x64 Installer depuis cette page. IMPORTANT : pendant l'installation, cochez bien Add CMake to the system PATH for the current user (ou Add CMake to the system PATH for all users).    CMake est l'outil de build le plus r√©pandu pour C++. Il explique au compilateur comment compiler votre projet. Vous ne l'utiliserez pas directement, mais il est n√©cessaire pour que tout build correctement.  ","version":"Next","tagName":"h2"},{"title":"Installer VSCode‚Äã","type":1,"pageTitle":"Partie 1 - Setup","url":"/Rendering/M1 GP/Partie 1 - Setup#installer-vscode","content":" T√©l√©chargez-le depuis cette page.  VSCode est l'IDE (&quot;√©diteur de texte&quot;) que je vous conseille d'utiliser pour √©crire votre code C++. (Vous pouvez utiliser un autre IDE si vous voulez, mais ce cours n'expliquera pas comment le setup pour faire compiler votre projet).  ","version":"Next","tagName":"h2"},{"title":"Installer les extensions VSCode pour C++‚Äã","type":1,"pageTitle":"Partie 1 - Setup","url":"/Rendering/M1 GP/Partie 1 - Setup#installer-les-extensions-vscode-pour-c","content":" cpptools-extension-pack: Les extensions C++ de base, obligatoires pour compiler votre projet.webgl-glsl-editor: L'extension GLSL, pour avoir de l'autocompl√©tion quand vous √©crirez des shaders.BuildOutputColorizer: Pour que les messages d'erreur apparaissent en rouge dans la console, tr√®s pratique.code-spell-checker: Un correcteur d'orthographe. Marche pour l'anglais et le fran√ßais. (Pour le configurer pour le fran√ßais, installez en plus code-spell-checker-french et suivez les instructions qui sont sur la page de t√©l√©chargement).vscode-great-icons: Des ic√¥nes pour plein de types de fichier (.cpp, .hpp, CMakeLists.txt, etc.).cmake-language-support-vscode: Autocompl√©tion pour CMake.  ","version":"Next","tagName":"h2"},{"title":"Installer RenderDoc‚Äã","type":1,"pageTitle":"Partie 1 - Setup","url":"/Rendering/M1 GP/Partie 1 - Setup#installer-renderdoc","content":" T√©l√©chargez-le depuis cette page.  RenderDoc est un d√©bugueur pour GPU. Il permet de voir tout ce qu'il s'est pass√© dans la carte graphique pendant le rendu d'une frame donn√©e. Il permet de voir l'√©tat de vos meshs, les diff√©rentes √©tapes de la construction de l'image finale, et plein d'autres choses encore ! Nous allons beaucoup nous en servir au fil des TPs, √† la fois pour d√©buguer notre code, et aussi juste pour inspecter et mieux comprendre ce qu'il se passe dans la carte graphique.  ","version":"Next","tagName":"h2"},{"title":"T√©l√©charger la base de code‚Äã","type":1,"pageTitle":"Partie 1 - Setup","url":"/Rendering/M1 GP/Partie 1 - Setup#t√©l√©charger-la-base-de-code","content":" Vous √™tes maintenant pr√™t.e √† coder ! Nous allons partir de ce template de code qui inclue toutes les libraires n√©cessaires. Vous pouvez directement cr√©er un repository GitHub √† partir de celui-ci en faisant Use this template :    (Et sinon vous pouvez aussi juste t√©l√©charger le code normalement, et cr√©er un repo de votre c√¥t√©).  ","version":"Next","tagName":"h2"},{"title":"Compiler‚Äã","type":1,"pageTitle":"Partie 1 - Setup","url":"/Rendering/M1 GP/Partie 1 - Setup#compiler","content":" Pour lancer votre projet, il vous suffit maintenant d'appuyer sur le petit insecte depuis VSCode. La premi√®re fois, il va vous demander quel compilateur vous voulez utiliser : il faudra probablement faire [Scan for kits], puis s√©lectionnez le compilateur qui mentionne amd64.   ","version":"Next","tagName":"h2"},{"title":"Partie 2 - Bases du rendu","type":0,"sectionRef":"#","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu","content":"","keywords":"","version":"Next"},{"title":"La structure de l'application‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#la-structure-de-lapplication","content":" Pour l'instant dans src/main.cpp vous avez ceci :  #include &quot;opengl-framework/opengl-framework.hpp&quot; // Inclue la librairie qui va nous servir √† faire du rendu int main() { // Initialisation gl::init(&quot;TPs de Rendering&quot;); // On cr√©e une fen√™tre et on choisit son nom gl::maximize_window(); // On peut la maximiser si on veut while (gl::window_is_open()) { // Rendu √† chaque frame } }   La boucle while est ce qu'on appelle la boucle de rendu ; chaque it√©ration correspond √† une frame, et il faudra y mettre le code dessinant ce qu'on veut pour cette frame.  En ex√©cutant ce code, vous devriez avoir une fen√™tre noire qui s'ouvre :  ","version":"Next","tagName":"h2"},{"title":"Couleur de fond‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#couleur-de-fond","content":" Pour commencer tr√®s simplement on peut choisir la couleur de fond, au d√©but de la boucle de rendu :  glClearColor(0.f, 0.f, 1.f, 1.f); // Choisis la couleur √† utiliser. Les param√®tres sont R, G, B, A avec des valeurs qui vont de 0 √† 1 glClear(GL_COLOR_BUFFER_BIT); // Ex√©cute concr√®tement l'action d'appliquer sur tout l'√©cran la couleur choisie au-dessus     Note En plus de choisir la couleur, l'op√©ration glClear(GL_COLOR_BUFFER_BIT) est tr√®s importante car elle reset l'image entre deux frames. Sans elle, les objets dessin√©s ne disparaissent pas d'une frame √† l'autre (ce qui peut permettre des effets artistiques int√©ressants, mais est emb√™tant pour un rendu &quot;classique&quot;). Vous pourrez essayer √ßa un peu plus tard quand nous saurons dessiner des objets qui bougent.  ","version":"Next","tagName":"h2"},{"title":"OpenGL‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#opengl","content":" Nous utilisons l'API OpenGL pour communiquer avec la carte graphique. Il en existe d'autres, mais elles sont soit plus difficiles √† apprendre (Vulkan, WebGPU), soit sp√©cifiques √† un OS (DirectX pour Windows, Metal pour Mac).  Si jamais vous cherchez de l'aide sur Internet ou ChatGPT, pensez √† bien pr√©ciser OpenGL dans votre recherche. Et sinon, vous trouverez la documentation de toutes les fonctions OpenGL sur docs.gl.  Remarque Tout ce qui commence par gl:: (comme gl::init()) ne fait pas partie de l'API OpenGL de base, mais d'un wrapper que je vous fournis pour vous simplifier la vie. Par contre ce qui commence par gl (comme glClearColor) fait partie de l'API OpenGL officielle.  ","version":"Next","tagName":"h2"},{"title":"Mesh‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#mesh","content":" ","version":"Next","tagName":"h2"},{"title":"Vertex Buffer et Premier Triangle‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#vertex-buffer-et-premier-triangle","content":" Nous allons maintenant dessiner notre premier objet ! Pour d√©crire notre objet √† la carte graphique, nous utilisons un mesh, c'est-√†-dire une longue liste de triangles qui, mis bout-√†-bout, dessinent notre forme en 3D :    Pendant l'initialisation nous pouvons cr√©er un objet de type gl::Mesh :  auto const triangle_mesh = gl::Mesh{{ .vertex_buffers = {{ .layout = {gl::VertexAttribute::Position2D{0 /*Index de l'attribut dans le shader, on en reparle juste apr√®s*/}}, .data = { -1.f, -1.f, // Position2D du 1er sommet +1.f, -1.f, // Position2D du 2√®me sommet 0.f, +1.f // Position2D du 3√®me sommet }, }}, }};   que nous allons ensuite dessiner √† chaque frame dans la boucle de rendu :  gl::bind_default_shader(); // On a besoin qu'un shader soit bind (i.e. &quot;actif&quot;) avant de draw(). On en reparle dans la section d'apr√®s. triangle_mesh.draw(); // C'est ce qu'on appelle un &quot;draw call&quot; : on envoie l'instruction √† la carte graphique de dessiner notre mesh.     Il y a d√©j√† plein de chose √† dire ! Quand on cr√©e un mesh, on lui passe un vertex buffer :  .vertex_buffers = {{ .layout = {gl::VertexAttribute::Position2D{0 /*Index de l'attribut dans le shader, on en reparle juste apr√®s*/}}, .data = { -1.f, -1.f, // Position2D du 1er sommet +1.f, -1.f, // Position2D du 2√®me sommet 0.f, +1.f // Position2D du 3√®me sommet }, }},   Un vertex buffer c'est le tableau qui contient toutes les donn√©es d√©crivant notre mesh : position des sommets des triangles, mais √©galement plein d'autres donn√©es optionnelles : couleur, normale, coordonn√©e de texture (UV), etc. En fait c'est nous qui d√©cidons quoi mettre dans ce buffer, puis que faire de ces donn√©es quand on code le vertex shader (que nous verrons plus tard). Pour faire du rendu classique on utilise g√©n√©ralement position + normales + UV. Mais on peut aussi imaginer d'autres usages plus cr√©atifs et rajouter toutes les donn√©es dont on pourrait avoir besoin pour un effet pr√©cis.  Remarque Un usage original : on peut stocker la distance au tronc sur chaque vertex des branches et feuilles des arbres. Cette distance est ensuite utilis√©e pour calculer √† quel point la branche peut ployer sous l'effet du vent. (La partie attach√©e au tronc ne doit pas bouger, et plus on s'en √©loigne plus on peut bouger librement). Stocker cette distance dans le vertex buffer √©vite de la recalculer √† chaque frame : c'est beaucoup plus optimis√©. C'est utilis√© dans God of War par exemple :  D√©crire ce vertex buffer se passe en deux √©tapes : son layout et ses data. Le layout indique comment data est structur√© : dans notre exemple on a juste des positions 2D qui s'encha√Ænent, mais √ßa pourrait aussi √™tre des positions 3D, et on pourrait aussi avoir d'autres attributs dans le m√™me tableau data, par exemple des coordonn√©es de texture, comme on verra plus tard. Pour chaque attribut du layout, il faut pr√©ciser son index (0 dans notre cas), une information qui nous servira plus tard pour r√©cup√©rer l'attribut du c√¥t√© du shader.  Vous remarquerez aussi que vertex_buffers est un tableau de vertex buffers ! Il est en effet possible d'avoir plusieurs vertex buffers, par exemple un qui stocke les positions, et un autre qui stocke les normales. √áa revient au m√™me que de mettre tous les attributs dans le m√™me vertex buffer, mais √ßa peut avoir des performances soit meilleures soit pires, en fonction des situations. C'est une question un peu compliqu√©e dont nous ne soucierons pas, et nous utiliserons simplement ce qui est le plus pratique pour nous.  Enfin, dans data nous mettons nos positions 2D :  .data = { -1.f, -1.f, // Position2D du 1er sommet +1.f, -1.f, // Position2D du 2√®me sommet 0.f, +1.f // Position2D du 3√®me sommet },   Le syst√®me de coordonn√©es marche ainsi : x et y vont toujours de -1 √† 1. Ainsi, x = -1 repr√©sente toujours le c√¥t√© gauche de la fen√™tre, et y = 1 repr√©sente toujours le haut de la fen√™tre. Vous remarquerez donc que quand vous redimensionnez la fen√™tre, le triangle se &quot;d√©forme&quot; pour continuer √† remplir toute la fen√™tre. Ce n'est g√©n√©ralement pas ce qu'on veut, et nous verrons comment rem√©dier √† √ßa plus tard.  ","version":"Next","tagName":"h3"},{"title":"RenderDoc‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#renderdoc","content":" Avant d'aller plus loin, nous allons commencer √† d√©couvrir RenderDoc, un super outil qui nous permettra de d√©buguer si jamais notre rendu ne se fait pas comme on voudrait.  Remarque Si jamais vous avez besoin de RenderDoc dans Unreal ou Unity, c'est possible ! Vous pouvez ouvrir ces moteurs directement dans RenderDoc, mais m√™me encore mieux il y a un plugin RenderDoc pour Unreal, et le Frame Debugger pour Unity qui est un √©quivalent de RenderDoc int√©gr√© directement dans Unity.  La premi√®re chose √† faire quand vous ouvrez RenderDoc, c'est d'aller dans l'onglet Launch Application pour choisir l'ex√©cutable √† d√©buguer (qui va se trouver dans le dossier de votre projet, et le sous-dossier build. Il devrait s'appeler TPs-Rendering.exe):    Une fois que s'est fait, vous pouvez cliquer sur Launch :    qui va lancer votre application en &quot;mode RenderDoc&quot; :    Vous pouvez alors faire F12 pour capturer une frame, puis fermer l'application, et RenderDoc va vous permettre d'inspecter la frame que vous venez de capturer :    La premi√®re chose √† regarder, c'est la timeline sur le c√¥t√©, qui indique toutes les op√©rations OpenGL qui ont √©t√© ex√©cut√©es pendant la frame. Vous pouvez cliquer sur chacune d'elle, et voir le rendu √† ce moment l√† de la frame :    Dans notre cas c'est tr√®s simple, il y a la couleur de fond qui est faite avec glClear, puis le draw call de notre mesh avec glDrawArrays (le 3 indique qu'il y avait 3 sommets dans notre vertex buffer).  Ensuite on peut inspecter chaque √©tape du rendu en cliquant dessus. Ce qui va nous int√©resser c'est le draw call de notre mesh, donc cliquez sur l'√©tape glDrawArrays.  La premi√®re chose √† faire, si typiquement votre mesh ne s'affiche pas, c'est d'aller dans Overlay, et de s√©lectionner Highlight Drawcall. √áa va indiquer l√† o√π votre mesh a atterri √† l'√©cran.    Si vous voyez bien votre mesh en magenta dans le draw call, mais qu'ensuite le triangle ne s'affiche pas, c'est d√©j√† une tr√®s bonne information ! Dans ce cas vous pouvez ensuite passer le mode d'overlay en Depth Test, puis Stencil Test, puis Backface Cull. Si l'un d'eux affiche votre mesh en rouge, c'est que cette √©tape du rasterizer a d√©cid√© de skipper votre mesh. Nous reparlerons de ces √©tapes plus tard (Depth Test, Stencil Test, Backface Culling). Sinon, si tout est vert mais que votre mesh ne s'affiche quand m√™me pas, c'est probablement au niveau du fragment shader qu'il y a un probl√®me.  Si √† l'inverse d√®s l'overlay Highlight Drawcall vous ne voyez pas votre mesh, alors c'est le mesh lui-m√™me qui a un probl√®me. Vous pouvez alors aller dans l'onglet Mesh Viewer :    Ici vous avez plein d'informations : d'abord la vue VS In vous montre votre mesh tel qu'il √©tait avant le vertex shader :    Si votre mesh appara√Æt bien ici, tant mieux ! Et sinon, c'est probablement que votre vertex buffer n'est pas bon ! Vous pouvez inspecter votre vertex buffer dans la vue VS Input, et regarder si il y a des valeurs bizarres / pas assez de vertexs / un layout qui ne correspond pas √† ce que vous pensiez avoir sp√©cifi√©, etc. Dans cet example, on voit que tout va bien, et on retrouve les valeurs qu'on avait mises dans notre vertex buffer :    Ensuite, vous pouvez aller voir dans VS Out l'√©tat de votre mesh apr√®s le vertex shader. Dans les sections suivantes nous appliquerons des transformations au mesh dans le vertex shader (d√©placement, cam√©ra, etc.), et vous pourrez voir le r√©sultat ici :    Et une fois de plus, si vous avez besoin d'inspecter les valeurs pr√©cises, elles sont toutes dans la vue VS Output :    RenderDoc permet encore beaucoup d'autres choses, mais vous avez vu l'essentiel qui vous sauvera 99% du temps !  ","version":"Next","tagName":"h3"},{"title":"Dessiner un rectangle‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#dessiner-un-rectangle","content":" Maintenant, √† vous de jouer ! Modifiez le code qui cr√©e votre mesh afin d'avoir non plus un triangle, mais un rectangle qui prendra la moiti√© de l'√©cran. Il vous faudra dessiner deux triangles, et donc indiquer six sommets dans le vertex buffer.  Si vous avez un probl√®me de rendu, pensez √† aller voir dans RenderDoc ce qu'il se passe !    ","version":"Next","tagName":"h3"},{"title":"Index buffer‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#index-buffer","content":" Vous avez peut-√™tre remarqu√© une chose en faisant le vertex buffer du rectangle, c'est que vous avez d√ª √©crire certains sommets deux fois ! (Une fois pour dessiner le premier triangle, puis une deuxi√®me fois pour le deuxi√®me triangle). Et d'ailleurs, six sommets pour un rectangle √ßa fait beaucoup, 4 devraient suffire ! C'est un probl√®me qui devient d'autant plus emb√™tant que sur un vrai mesh les sommets sont parfois partag√©s par bien plus que deux triangles, et donc doivent √™tre dupliqu√©s plein de fois, ce qui augmente consid√©rablement la taille du mesh.  Heureusement, ce probl√®me a une solution : l'index buffer !  Quand on cr√©e notre gl::Mesh on peut, en plus du vertex buffer, sp√©cifier un index buffer :  auto const rectangle_mesh = gl::Mesh{{ .vertex_buffers = {{ .layout = {gl::VertexAttribute::Position2D{0}}, .data = { -0.5f, -0.5f, // Position2D du 1er sommet +0.5f, -0.5f, // Position2D du 2√®me sommet +0.5f, +0.5f, // Position2D du 3√®me sommet -0.5f, +0.5f // Position2D du 4√®me sommet }, }}, .index_buffer = { 0, 1, 2, // Indices du premier triangle : on utilise le 1er, 2√®me et 3√®me sommet 0, 2, 3 // Indices du deuxi√®me triangle : on utilise le 1er, 3√®me et 4√®me sommet }, }};   Les indices dans l'index buffer vont par 3, et d√©crivent un triangle en indiquant quels sommets prendre dans le vertex buffer.    Le rendu est exactement le m√™me, mais notre vertex buffer est plus simple √† √©crire, et plus l√©ger pour l'ordinateur !  Vous allez pouvoir tester d'√©crire vous-m√™me un index buffer quand vous ferez un cube, mais avant cela il nous manque quelques √©tapes pour passer en 3D !  ","version":"Next","tagName":"h3"},{"title":"Shader‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#shader","content":" Un Shader est un programme ex√©cut√© par la carte graphique. Il existe deux principaux types de shaders :  Le Vertex Shader qui prend un sommet dans notre vertex buffer et le modifie (d√©placement, application de la perspective 3D, etc.)Le Fragment Shader qui prend un pixel de notre triangle et le colorie (en fonction de son mat√©riau, de la lumi√®re, etc.)  Remarque Il existe aussi les Compute Shaders qui sont plus g√©n√©riques et prennent n'importe quel type de buffer et le modifient. Ils sont tr√®s utilis√©s pour faire des simulations sur GPU (particules, fluides, v√™tements, etc.).  Pour cr√©er un shader, il vous suffit de faire, dans l'initialisation :  auto const shader = gl::Shader{{ .vertex = gl::ShaderSource::File{&quot;res/vertex.glsl&quot;}, .fragment = gl::ShaderSource::File{&quot;res/fragment.glsl&quot;}, }};   et de cr√©er les deux fichiers correspondants, dans le dossier res :  res/vertex.glsl #version 410 layout(location = 0) in vec2 in_position; void main() { gl_Position = vec4(in_position, 0., 1.); }   res/fragment.glsl #version 410 out vec4 out_color; void main() { out_color = vec4(1.); }   IMPORTANT Tous les assets (shader, texture, mod√®le 3D, etc.) doivent √™tre mis dans le dossier res, et pas un autre, car ce dossier est copi√© pour √™tre mis √† c√¥t√© de l'exe dans le dossier build. (C'est fait dans le CMakeLists.txt, par la ligne gl_target_copy_folder(${PROJECT_NAME} res)). Si jamais vous vouliez renommer le dossier res ou en ajouter un autre, il faudrait bien penser √† aller modifier le CMakeLists.txt !  Puis pour utiliser ce shader √† la place du shader par d√©faut, remplacez la ligne gl::bind_default_shader(); par shader.bind(); :    Le rendu n'a toujours pas chang√©, car les shaders que je vous ai donn√©s sont √©quivalents aux shaders par d√©faut qu'on utilisait jusque l√†. Mais √ßa ne saurait tarder, nous allons maintenant pouvoir modifier nos shaders comme on veut ! Mais avant tout, quelques explications :  ","version":"Next","tagName":"h2"},{"title":"GLSL‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#glsl","content":" D√©j√†, le GLSL est le langage utilis√© pour √©crire des shaders. Il ressemble tr√®s fort √† du C, avec en plus quelques fonctions et types tr√®s souvent utilis√©s en rendu 3D : vecteurs (vec2, vec3, vec4), matrices (mat2, mat3, mat4), et fonctions g√©om√©triques (produit scalaire dot(v1, v2), normalisation d'un vecteur normalize(v), etc.).  Chaque shader doit commencer par une indication de la version utilis√©e (#version 410). Nous utilisons la 410, qui est la derni√®re support√©e par MacOS. (Et sinon elles vont jusqu'√† 460, mais il n'y a aucune diff√©rence en ce qui nous concerne).  ","version":"Next","tagName":"h3"},{"title":"Vertex Shader‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#vertex-shader","content":" Le vertex shader commence par une d√©claration des attributs :  layout(location = 0) in vec2 in_position;   Ces attributs doivent correspondre au layout de notre vertex buffer :  .vertex_buffers = {{ .layout = {gl::VertexAttribute::Position2D{0 /*Index de l'attribut dans le shader*/}}, .data = { // ... }, }},   Le layout(location = 0) correspond √† l'index 0 sp√©cifi√© pour gl::VertexAttribute::Position2D, et le type vec2 vient du fait que nos positions 2D sont des vecteurs √† deux composantes (si on utilisait des positions 3D, il faudrait mettre vec3). Le nom in_position est libre et vous pouvez mettre ce que vous voulez.  Ensuite, dans la fonction main() on assigne la variable gl_Position, qui est une variable sp√©ciale indiquant √† OpenGL la position finale du vertex (ce qui correspond au VS Out qu'on avait vu dans RenderDoc).  En guise de premier exercice, vous pouvez d√©placer le rectangle via le vertex shader, par exemple de 0.4 en x et en y :    ","version":"Next","tagName":"h3"},{"title":"Fragment Shader‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#fragment-shader","content":" Le fragment shader commence par  out vec4 out_color;   qui d√©clare la variable de sortie : ce qu'on assigne √† cette variable correspondra √† la couleur du pixel √† l'√©cran.  Et dans le main() on fait quelque chose de tr√®s simple, qui est d'assigner la m√™me couleur √† tous les pixels, sans r√©fl√©chir :  out_color = vec4(1.);   Note La syntaxe vec4(1.) est un raccourci pour vec4(1., 1., 1., 1.). On peut m√™me faire des choses comme vec4(vec3(0.5), 1.), qui revient √† faire vec4(0.5, 0.5, 0.5, 1.).Les composantes R, G, B et A des couleurs vont de 0 √† 1, donc vec3(1., 1., 1.) correspond √† mettre le maximum de rouge, vert et bleu, donc du blanc pur.  En guise de premier exercice, vous pouvez changer la couleur du rectangle :    ","version":"Next","tagName":"h3"},{"title":"Envoyer des param√®tres au shader : les uniforms‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#envoyer-des-param√®tres-au-shader--les-uniforms","content":" Pour que nos shaders deviennent int√©ressants, il faut leur envoyer plus de donn√©es en entr√©e. On peut soit rajouter des attributs dans le vertex buffer (couleur, UV, normale, etc.), ce que nous verrons plus tard ; soit envoyer des param√®tres appel√©s uniforms. Une variable uniforme se d√©clare ainsi dans le shader, au-dessus du main() :  uniform vec2 nom_de_votre_variable_uniforme; // Vous pouvez mettre le type que vous voulez, et le nom que vous voulez   puis peut s'utiliser dans votre shader comme vous le voulez, comme n'importe quelle variable normale.  Pour assigner la valeur d'une variable uniforme, cela se fait dans votre code C++, apr√®s avoir bind le shader :  shader.set_uniform(&quot;nom_de_votre_variable_uniforme&quot;, glm::vec2{1.f, 3.f});   Remarque On utilise la librairie glm pour avoir des types vecteur et matrice comme en glsl : glm::vec2, glm::vec3, glm::vec4, glm::mat2, glm::mat3, glm::mat4, etc.  Note Une variable uniform s'appelle ainsi car elle est uniforme pour un draw call : √ßa sera la m√™me pour tous les vertexs et pour tous les pixels lors d'un appel donn√© √† mesh.draw(). Si on voulait une valeur qui est diff√©rente pour chaque vertex, il faudrait passer par un attribut de vertex.  On peut par exemple utiliser les uniforms pour r√©gler notre probl√®me de taille de rectangle qui suit la fen√™tre. Pour cela, nous allons passer au shader l'aspect ratio de la fen√™tre (i.e. largeur / hauteur), et corriger la position en x de nos vertexs en fonction du ratio.  D√©clarez une uniform aspect_ratio de type float dans le vertex shaderDivisez le x de la position de votre vertex par aspect_ratioC√¥t√© C++, passez la uniform au shader (Vous pouvez obtenir l'aspect ratio de la fen√™tre avec gl::framebuffer_aspect_ratio())  Enfin un carr√© qui reste carr√© peu importe la taille de la fen√™tre !  Remarque On pourrait se dire qu'il suffisait de cr√©er un nouveau vertex buffer avec des positions qui prennent en compte l'aspect ratio, et de recr√©er le buffer √† chaque fois que l'aspect ratio change. Mais √ßa impliquerait de modifier potentiellement les millions de vertexs de notre mesh, ce qui prendrait beaucoup de temps. Alors que le vertex shader lui va faire √ßa en un rien de temps : c'est la puissance de la carte graphique, qui peut traiter tous les sommets en parall√®le extr√™mement vite !  ","version":"Next","tagName":"h3"},{"title":"Exercice : Faire bouger le carr√©‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#exercice--faire-bouger-le-carr√©","content":" Vous pouvez utiliser gl::time_in_seconds() pour r√©cup√©rer le temps, l'envoyer au shader, et vous en servir pour faire bouger le carr√©. Le plus simple est de le faire aller en ligne droite, mais vous pouvez aussi (bonus) le faire aller et revenir, ou tourner en rond :     Remarque Maintenant qu'on a un objet qui bouge, on peut enfin tester ce qu'il se passe quand on enl√®ve la ligne glClear(GL_COLOR_BUFFER_BIT);. Je vous laisse essayer !  ","version":"Next","tagName":"h3"},{"title":"Bonus : effet de fade‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#bonus--effet-de-fade","content":" Vous avez toutes les cartes en main pour faire cet effet de fade, alors je vous laisse chercher comment faire üòâ  Info Vous aurez probablement besoin d'utiliser de la transparence √† un moment, qui n√©cessite d'√™tre activ√©e, au d√©but de l'initialisation, avec : glEnable(GL_BLEND); glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE); // On peut configurer l'√©quation qui m√©lange deux couleurs, comme pour faire diff√©rents blend mode dans Photoshop. Cette √©quation-ci donne le blending &quot;normal&quot; entre pixels transparents.     Remarque Si vous voyez un effet de clignotement, c'est normal, c'est d√ª √† la swapchain : en fait il y a deux images qui s'alternent : l'une qui est affich√©e √† l'√©cran, et l'autre sur laquelle on est en train de dessiner. (Si on dessinait sur l'image qui est actuellement affich√©e √† l'√©cran, on verrait les pixels se dessiner petit √† petit et √ßa ferait tr√®s moche). Pour r√©soudre ce clignotement, il faudrait faire le rendu de toute notre sc√®ne dans une render target √† part, qu'on copierait √† l'√©cran √† la fin de chaque frame. Nous verrons cette notion plus tard.  Remarque Il reste une trace qui ne s'efface pas, c'est d√ª √† des probl√®mes d'arrondi au moment du calcul de la transparence, car chaque canal de couleur est stock√© sur un entier √† 8 bits seulement (par d√©faut). En faisant notre rendu sur une render target utilisant 16 bits par canal, √ßa r√©soudrait le probl√®me.  Remarque Cet effet d√©pend du framerate ! Si vous dessinez deux fois plus d'images par seconde, la trace va s'effacer deux fois plus vite. Pour √©viter cela, il faudrait prendre en compte gl::delta_time_in_seconds(), qui donne le temps √©coul√© entre deux frames.  ","version":"Next","tagName":"h3"},{"title":"Cam√©ra et Matrices‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#cam√©ra-et-matrices","content":" Il est temps de passer en 3D !  Pour cela nous avons besoin de deux informations :  Le point de vue, i.e. savoir o√π on est dans l'espace, et dans quelle direction on regardeLa projection, pour donner l'effet de perspective inh√©rent √† la 3D  Pour repr√©senter ces deux informations, nous allons utiliser des matrices. Une matrice est un objet math√©matique qui permet de repr√©senter une transformation g√©om√©trique. On applique une matrice √† un vecteur (point ou direction, en 2D ou en 3D) pour lui appliquer la transformation g√©om√©trique repr√©sent√©e par la matrice. Par exemple on peut cr√©er une matrice de rotation qui, quand elle est appliqu√©e √† un point, fait tourner ce point.  Remarque Une matrice est un grille de nombre. Par exemple une matrice 3D (mat3) ressemblerait √† : (104012001)\\begin{pmatrix} 1 &amp; 0 &amp; 4 \\\\ 0 &amp; 1 &amp; 2 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix}‚Äã100‚Äã010‚Äã421‚Äã‚Äã Je ne rentrerai pas dans les d√©tails de quels nombres mettre dans la matrice pour repr√©senter quelle transformation, car nous allons utiliser la librairie glm pour cr√©er toutes ces matrices.  Le gros int√©r√™t des matrices est qu'on peut les combiner entre elles en les multipliant ! Par exemple si j'ai une matrice 3D de rotation R et une matrice 3D de translation T, alors R * T est une nouvelle matrice 3D, dont la transformation g√©om√©trique est une translation suivie d'une rotation (NB : la transformation de droite est appliqu√©e en premi√®re).  On peut ainsi construire une seule matrice finale, repr√©sentant la combinaison du point de vue (view matrix) et de la projection (projection matrix). On peut aussi y rajouter une modification de notre mesh (pour faire tourner le mesh, le translater pour le positionner dans le monde o√π on veut, etc.) (model matrix). Ensuite on envoie cette seule matrice au shader, il l'applique √† la position de nos vertexs, et le tour est jou√© !  Attention L'ordre des matrices a son importance ! R * T est diff√©rent de T * R. T * R est une rotation suivie d'une translation, ce qui est diff√©rent de d'abord faire la translation puis la rotation, comme vous pourrez le constater dans l'exercice qui suit.  Remarque On ne peut pas repr√©senter n'importe quelle transformation g√©om√©trique avec des matrices, seulement celles qui sont affines. Mais c'est d√©j√† bien assez, car les translations, les rotations et les aggrandisements sont toutes des transformations affines. Vous pouvez tester cette d√©mo interactive pour voir quel genre de transformation g√©om√©trique une matrice peut produire, et aussi regarder cette excellentissime vid√©o.  ","version":"Next","tagName":"h2"},{"title":"View Matrix‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#view-matrix","content":" Pour obtenir la View Matrix nous allons utiliser une cam√©ra, que nous pourrons contr√¥ler pour se d√©placer dans le monde :  // Dans l'initialisation auto camera = gl::Camera{};   puis, pour que la cam√©ra puisse r√©agir aux √©v√®nements (clic, d√©placement de la souris, etc.), il faut la connecter aux √©v√®nements fournis par la librairie gl :  // Dans l'initialisation gl::set_events_callbacks({camera.events_callbacks()});   Une fois que c'est fait, on peut r√©cup√©rer la matrice de vue avec :  // √Ä chaque frame glm::mat4 const view_matrix = camera.view_matrix();   Remarque gl::set_events_callbacks() prend un tableau de callbacks, donc on pourrait rajouter nos propres callbacks en plus de ceux de la cam√©ra : gl::set_events_callbacks({ camera.events_callbacks(), { .on_mouse_pressed = [&amp;](gl::MousePressedEvent const&amp; e) { std::cout &lt;&lt; &quot;Mouse pressed at &quot; &lt;&lt; e.position.x &lt;&lt; &quot; &quot; &lt;&lt; e.position.y &lt;&lt; '\\n'; }, }, });   ","version":"Next","tagName":"h3"},{"title":"Projection Matrix‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#projection-matrix","content":" Il nous faut encore la matrice de projection. Celle-ci est plus simple et s'obtient directement gr√¢ce √† glm :  glm::mat4 const projection_matrix = glm::infinitePerspective(1.f /*field of view in radians*/, gl::framebuffer_aspect_ratio() /*aspect ratio*/, 0.001f /*near plane*/);   (Attention, il faudra inclure le bon fichier de glm au d√©but de main.cpp : #include &quot;glm/ext/matrix_clip_space.hpp&quot;)  Ses diff√©rents param√®tres sont :  Le field of view (angle de vue). Vous avez peut-√™tre d√©j√† vu ce param√®tre dans des jeux vid√©os. Plus il est large, plus on voit une grande partie de la sc√®ne √† la fois (attention, avec des valeurs trop grande les objets commencent √† appara√Ætre d√©form√©s), plus il est petit moins on voit une grande portion de la sc√®ne, √ßa zoom. Attention, il est exprim√© en radians, donc pour un fov de 45¬∞ il faudra √©crire glm::radians(45.f).L'aspect ratio de la fen√™tre. La petite division par aspect_ratio qu'on avait fait pr√©c√©demment pour corriger notre probl√®me de stretch est g√©r√©e automatiquement par la matrice de projection, vous pouvez donc enlever cette ligne du vertex shader.Le near plane : √† cause de limitations techniques, les objets trop proches de la cam√©ra ne peuvent pas √™tre visibles. Le near plane d√©finit √† partir de quelle distance on commence √† voir les objets. Plus on le met proche de 0, plus on √©vitera d'avoir des objets coup√©s, mais si on le met trop petit on peut commencer √† avoir des erreurs d'arrondis dans nos calculs entre float, ce qui causerait d'autres probl√®mes dans notre rendu.Le far plane : on n'en a pas ici car on utilise glm::infinitePerspective(), mais si on utilisait glm::perspective() on en aurait un. Similaire au near plane, il d√©finit la distance √† partir de laquelle on ne voit plus les objets.  Remarque Il y a aussi un autre type de projection : la projection orthographique. Elle ne fait pas intervenir de perspective, donc les objets lointains apparaissent √† la m√™me taille que les objets proches. Ce n'est pas r√©aliste, mais peut √™tre int√©ressant pour donner un style au rendu.  ","version":"Next","tagName":"h3"},{"title":"Envoyer au shader‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#envoyer-au-shader","content":" Maintenant qu'on a ces deux matrices, on peut les multiplier entre elles pour former la view_projection_matrix (‚ö† Attention, la view doit s'appliquer en premier, et la projection en deuxi√®me ! R√©fl√©chissez donc bien √† l'ordre dans lequel vous multipliez vos matrices), et envoyer cette view_projection matrix au shader (d√©clarez une uniform de type mat4). Enfin, il ne reste plus qu'√† multiplier dans le shader la matrice √† la position de nos vertexs :  gl_Position = view_projection_matrix * vec4(in_position, 0., 1.);   Remarque Nos matrices sont des mat4 alors qu'on est en 3D. C'est parce qu'on utilise une &quot;astuce&quot; qui sont les coordonn√©es homog√®nes, et sans lesquelles on ne pourrait pas faire de translation ni de perspective. C'est pour √ßa qu'on a besoin de rajouter une coordonn√©e de plus que la dimension de l'espace. C'est aussi pour √ßa qu'on rajoute un 1 en quatri√®me coordonn√©e de nos positions (vec4(in_position, 0., 1.)).    ","version":"Next","tagName":"h3"},{"title":"Exercice : param√®tres de la projection‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#exercice--param√®tres-de-la-projection","content":" Essayez de changer les param√®tres de la matrice de projection (field of view, near plane) et essayez d'observer la diff√©rence de rendu. Essayez aussi d'utiliser une projection orthographique. (Je vous laisse chercher en ligne comment on fait √ßa avec glm).  ","version":"Next","tagName":"h3"},{"title":"Exercice : model matrix‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#exercice--model-matrix","content":" On peut rajouter un troisi√®me matrice √† la view_projection_matrix, pour former la model_view_projection_matrix ! (Attention, la model matrix doit s'appliquer en premier).  Avec glm vous pouvez cr√©er une matrice de rotation avec  glm::mat4 const rotation = glm::rotate(glm::mat4{1.f}, gl::time_in_seconds() /*angle de la rotation*/, glm::vec3{0.f, 0.f, 1.f} /* axe autour duquel on tourne */);   et une matrice de translation avec  glm::mat4 const translation = glm::translate(glm::mat4{1.f}, glm::vec3{0.f, 1.f, 0.f} /* d√©placement */);   (Il faudra include #include &quot;glm/ext/matrix_transform.hpp&quot;.)  Cr√©ez une matrice mod√®le qui combine une translation et une rotation, et observez le r√©sultat. Essayez les deux ordres (rotation suivie de translation, et vice-versa) et vous verrez que ce n'est pas pareil ! L'ordre a son importance !  ","version":"Next","tagName":"h3"},{"title":"Cube‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#cube","content":" Maintenant qu'on peut voir en 3D, il est temps de faire notre premier mesh 3D ! Faites le vertex buffer et l'index buffer pour un cube. Je vous laisse revoir le chapitre d√©di√© au besoin. Je vous conseille de faire des petits sch√©mas pour ne pas vous y perdre dans les indices, et y aller face par face.  Attention Pensez √† modifier aussi votre shader, pour qu'il re√ßoive une position 3D et plus 2D.    ","version":"Next","tagName":"h2"},{"title":"Premier shader pour mieux voir la 3D‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#premier-shader-pour-mieux-voir-la-3d","content":" On a du mal √† discerner la 3D sur notre cube monochrome. Nous allons donc changer notre fragment shader pour commencer √† un peu mieux voir tout √ßa.  Une mani√®re tr√®s simple va √™tre de passer la position des vertexs du vertex shader vers le fragment shader, puis d'utiliser ces positions comme des couleurs, afin que chaque vertex ait une couleur diff√©rente.  Pour cela dans le vertex shader nous allons d√©clarer une variable out, qui sera transmise au fragment shader automatiquement :  res/vertex.glsl // √Ä mettre avant le main out vec3 vertex_position;   puis on l'assigne dans le main :  res/vertex.glsl vertex_position = in_position;   et ensuite dans le fragment shader on d√©clare un variable in avec le m√™me nom et le m√™me type que la variable out de notre vertex shader :  res/fragment.glsl // √Ä mettre avant le main in vec3 vertex_position;   et on peut l'utiliser dans notre main :  res/fragment.glsl out_color = vec4(vertex_position, 1.);     Si votre cube vous para√Æt un peu bizarre, c'est normal, il nous manque encore un Depth Buffer pour faire de la 3D correctement !  ","version":"Next","tagName":"h2"},{"title":"Depth Buffer‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#depth-buffer","content":" Le probl√®me avec notre rendu pour l'instant, c'est que les triangles se dessinent les uns apr√®s les autres et se recouvrent. Et si par malchance c'est une face arri√®re du cube qui est dessin√©e en derni√®re, alors elle va venir cacher les faces avant qui ont √©t√© dessin√©es avant.  Pour rem√©dier √† √ßa, il faut activer le Depth Test :  // √Ä mettre dans l'initialisation glEnable(GL_DEPTH_TEST);   et clear le depth buffer √† chaque frame, tout comme on clear la couleur de l'√©cran :  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Vient remplacer glClear(GL_COLOR_BUFFER_BIT);     Et voil√† ! Notre premier rendu 3D qui ressemble √† peu pr√®s √† quelque chose ! üéâ  Et qu'est-ce donc qu'un Depth Buffer au fait ? C'est une deuxi√®me image, qui se cr√©e en parall√®le de la couleur qu'on met √† l'√©cran, et qui stocke la profondeur correspondant √† chaque pixel. Ainsi chaque triangle dessine √† la fois une couleur √† l'√©cran (contr√¥l√©e par le fragment shader), et aussi une &quot;couleur&quot; dans le depth buffer. Et avant m√™me de dessiner, on v√©rifie pour chaque pixel si il n'y avait pas d√©j√† eu quelque chose de dessin√© sur ce pixel, et si oui on compare leur profondeur, et on recolorie le pixel avec la nouvelle couleur seulement si il est plus proche de la cam√©ra que l'objet pr√©c√©demment dessin√© (on obtient cette distance √† la cam√©ra justement en allant lire le depth buffer).  On peut aller visualiser notre Depth Buffer dans RenderDoc :    Dans l'onglet Outputs il y a maintenant deux images : l'√©cran normal (Backbuffer Color), et le Depth Buffer (Backbuffer Depth-stencil). (NB : pour y voir quelque chose dans le depth buffer, il faut changer la Range, car comme le cube est tr√®s proche il appara√Æt tr√®s blanc dans le depth buffer).  Remarque On verra un usage cr√©atif du depth buffer pour faire un effet de rendu See-Through.  ","version":"Next","tagName":"h2"},{"title":"Texture‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#texture","content":" ","version":"Next","tagName":"h2"},{"title":"Bonus : textures proc√©durales en fonction des uvs, cf. Shadertoy‚Äã","type":1,"pageTitle":"Partie 2 - Bases du rendu","url":"/Rendering/M1 GP/Partie 2 - Bases du rendu#bonus--textures-proc√©durales-en-fonction-des-uvs-cf-shadertoy","content":"","version":"Next","tagName":"h3"}],"options":{"id":"default"}}